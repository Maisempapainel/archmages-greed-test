<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Archmage's Greed - Multiplayer Fixed</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            margin: 0;
            background-color: #111;
            color: white;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #050505;
        }

        canvas {
            background-color: #000;
            border: 2px solid #333;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.05);
        }

        /* UI Elements */
        .ui-layer {
            position: absolute;
            pointer-events: none;
            width: 1472px; 
            height: 690px;
        }

        #hud-top-left {
            position: absolute;
            top: 20px;
            left: 20px;
            text-align: left;
            display: none; 
        }

        #hud-top-right {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
            color: #4da6ff; 
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
            pointer-events: auto;
        }

        #souls-container { opacity: 1 !important; }

        #wave-display {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            color: white;
            text-shadow: 0 0 10px white;
            pointer-events: none;
        }

        /* Menus */
        .menu-screen {
            position: absolute;
            width: 1472px;
            height: 690px;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 100;
        }

        .hidden { display: none !important; }

        h1 { margin-bottom: 30px; text-transform: uppercase; font-size: 30px; text-align: center; }
        h2 { text-align: center; font-size: 20px; color: #4da6ff; margin-bottom: 20px; }
        
        .btn {
            background: transparent;
            border: 2px solid white;
            color: white;
            padding: 15px 30px;
            font-family: inherit;
            font-size: 16px;
            cursor: pointer;
            margin: 10px;
            transition: 0.2s;
        }
        .btn:hover { background: white; color: black; }
        .btn:disabled { opacity: 0.3; cursor: not-allowed; }

        .input-text {
            background: black;
            border: 2px solid white;
            color: #4da6ff;
            padding: 10px;
            font-family: inherit;
            font-size: 14px;
            margin-bottom: 15px;
            text-align: center;
            outline: none;
        }

        /* Character Select */
        .char-select-container { display: flex; gap: 20px; margin-bottom: 20px; flex-wrap: wrap; justify-content: center;}
        .char-card {
            border: 1px solid #555; padding: 10px; cursor: pointer; text-align: center; width: 120px;
        }
        .char-card.selected { border: 2px solid white; background: #222; }
        .char-locked { opacity: 0.5; filter: grayscale(100%); }

        /* Upgrade Screen */
        #upgrade-container { display: flex; flex-direction: row; flex-wrap: wrap; justify-content: center; gap: 15px; max-width: 1100px; }
        .upgrade-card {
            border: 2px solid white; width: 180px; min-height: 220px; padding: 15px; text-align: center; cursor: pointer;
            transition: opacity 0.5s, transform 0.2s; position: relative; display: flex; flex-direction: column;
            align-items: center; justify-content: flex-start; background: #000;
        }
        .upgrade-card:hover { transform: scale(1.05); z-index: 50; }
        .rarity-common { border-color: #fff; color: #fff; }
        .rarity-uncommon { border-color: #4dff4d; color: #4dff4d; }
        .rarity-epic { border-color: #bf00ff; color: #bf00ff; }
        .rarity-legendary { border-color: #ffd700; color: #ffd700; box-shadow: 0 0 15px #ffd700; }
        
        .card-locked { opacity: 0.6; pointer-events: none; }
        .card-unlocked { opacity: 1; pointer-events: auto; }
        .card-desc { font-size: 10px; margin-top: 10px; line-height: 1.4; color: #ccc; word-wrap: break-word; }
        .card-title { font-size: 14px; margin: 10px 0; min-height: 30px; display:flex; align-items:center; justify-content:center; line-height: 1.3;}
        .card-tier { font-size: 10px; font-weight: bold; margin-bottom: 5px; display: block; }

        /* Bars */
        .bar-container { width: 200px; height: 10px; background: #333; margin-bottom: 5px; border: 1px solid white; }
        .bar-fill { height: 100%; transition: width 0.2s; }
        #hp-bar { background: white; }
        
        #audio-hint {
            position: absolute; bottom: 50px; width: 100%; text-align: center; font-size: 10px; color: #666; animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }

        /* Audio Controls */
        #audio-controls {
            position: absolute; bottom: 20px; right: 20px; z-index: 1000; display: flex; align-items: center; gap: 10px; background: rgba(0,0,0,0.5); padding: 5px; border-radius: 5px;
        }
        input[type=range] { width: 80px; cursor: pointer; }

        /* Buttons */
        #pause-btn-ingame, #perk-list-btn, #stats-btn {
            cursor: pointer; border: 1px solid white; padding: 5px 10px; font-size: 12px; background: #222; color: white; font-family: inherit; display: none; 
        }
        #pause-btn-ingame:hover, #perk-list-btn:hover, #stats-btn:hover { background: #444; border-color: white; }
        #perk-list-btn { position: absolute; left: 20px; bottom: 20px; z-index: 900; pointer-events: auto; padding: 10px 15px; }
        #stats-btn { position: absolute; left: 120px; bottom: 20px; z-index: 900; pointer-events: auto; padding: 10px 15px; }

        #perk-modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 600px; height: 400px; background: rgba(10, 10, 10, 0.98); border: 2px solid white; z-index: 2000; padding: 20px; display: flex; flex-direction: column; overflow: hidden;
        }
        #perk-list-content { flex: 1; overflow-y: auto; margin-top: 10px; font-size: 10px; line-height: 1.8; }
        .perk-entry { border-bottom: 1px solid #333; padding: 8px 5px; display: flex; flex-direction: column; cursor: pointer; transition: 0.2s; }
        .perk-entry:hover { background: rgba(255,255,255,0.05); }
        .perk-entry .header { display: flex; justify-content: space-between; pointer-events: none;}
        .perk-entry .header span:last-child { color: #4da6ff; }
        .perk-desc { color: #aaa; font-size: 8px; margin-top: 5px; white-space: normal; line-height: 1.4; pointer-events: none; }

        #timer-bar-container { width: 100%; max-width: 800px; height: 5px; background: #333; margin-top: 20px; }
        #timer-bar { height: 100%; background: white; width: 100%; transition: width 1s linear; }

        /* Stats Panel */
        #stats-panel {
            position: absolute; top: 80px; left: 20px; background: rgba(0,0,0,0.8); border: 2px solid #555; padding: 15px; font-size: 10px; line-height: 2.0; pointer-events: none; border-radius: 5px; min-width: 200px; z-index: 10;
        }
        #stats-panel div { display: flex; justify-content: space-between; }

        /* Language Flags */
        .lang-select { display: flex; gap: 15px; margin-bottom: 20px; }
        .flag-btn { font-size: 16px; cursor: pointer; opacity: 0.5; transition: 0.2s; background: #222; border: 2px solid #555; color: white; padding: 10px 15px; font-family: inherit; }
        .flag-btn.active { opacity: 1; transform: scale(1.1); border-color: white;}
        .flag-btn:hover { opacity: 0.8; }
        
        /* Laser UI & Teleport UI */
        #laser-ui {
            display: none; position: absolute; top: 20px; left: 240px; width: 45px; height: 45px; border: 2px solid red; background: rgba(255,0,0,0.2); cursor: pointer; align-items: center; justify-content: center; flex-direction: column; border-radius: 5px; pointer-events: auto; z-index: 100;
        }
        #teleport-ui {
            display: none; position: absolute; top: 20px; left: 295px; width: 45px; height: 45px; border: 2px solid cyan; background: rgba(0,255,255,0.2); cursor: pointer; align-items: center; justify-content: center; flex-direction: column; border-radius: 5px; pointer-events: auto; z-index: 100;
        }
        #teleport-fade {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: white; opacity: 0; pointer-events: none; transition: opacity 0.7s ease; z-index: 9999; display: none;
        }

        /* Dev Console */
        #dev-console {
            position: absolute; bottom: 60px; left: 20px; z-index: 9999; background: rgba(0,0,0,0.85); padding: 10px; border: 2px solid #555; pointer-events: auto; border-radius: 5px;
        }
        #dev-input {
            background: #000; color: #0f0; border: none; font-family: inherit; font-size: 10px; width: 300px; outline: none; padding: 5px;
        }

        .lobby-players { display: flex; gap: 40px; margin-bottom: 20px; font-size: 12px; text-align: center; }
        .lobby-player-box { padding: 20px; border: 2px solid #555; width: 200px; }
        .ready-text { color: #4dff4d; display: none; margin-top: 10px; }

        /* Nova Lista de Servidores no Lobby */
        #server-status-container {
            width: 350px;
            max-height: 150px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #555;
            margin: 10px 0;
            padding: 5px;
            font-size: 8px;
            text-align: left;
            display: none;
        }
        .server-row { display: flex; justify-content: space-between; padding: 3px; border-bottom: 1px solid #333; }
        .server-row span:last-child { font-weight: bold; }
        .ping-good { color: #4dff4d; }   
        .ping-ok { color: #ffff00; }     
        .ping-bad { color: #ff4d4d; }    
        .ping-loading { color: #4da6ff; }
        #server-status-container::-webkit-scrollbar { width: 5px; }
        #server-status-container::-webkit-scrollbar-thumb { background: #555; }
    </style>
</head>
<body>

<div id="game-container">
    <div id="fade-overlay" style="position:absolute; top:0; left:0; width:100%; height:100%; background:black; opacity:0; pointer-events:none; z-index:9999;"></div>
    <div id="teleport-fade"></div>

    <canvas id="gameCanvas" width="1472" height="690"></canvas>

    <div class="ui-layer">
        <div id="hud-top-left">
            <div>HP <span id="hp-text">100/100</span></div>
            <div class="bar-container"><div id="hp-bar" class="bar-fill" style="width: 100%;"></div></div>
            <div id="mana-shield-indicator" style="display:none; font-size:10px; color:#4dff4d; margin-top:5px;">[SHIELD]</div>
            <div id="phoenix-indicator" style="display:none; font-size:10px; color:#ffd700; margin-top:5px;">[PHOENIX]</div>
        </div>
        
        <div id="laser-ui" onclick="if(game && game.player && (!Net.isOnline || Net.isHost)) game.player.activateLaser(); else if (Net.isOnline && !Net.isHost) Net.sendInputCmd('laser');">
            <span style="color:red; font-size:16px;">âš¡</span>
            <span id="laser-cd" style="font-size:8px; margin-top:2px;">PRONTO</span>
        </div>
        
        <div id="teleport-ui" onclick="if(game && game.player && (!Net.isOnline || Net.isHost)) game.player.activateTeleport(); else if (Net.isOnline && !Net.isHost) Net.sendInputCmd('teleport');">
            <span style="color:cyan; font-size:16px;">ðŸŒ€</span>
            <span id="teleport-cd" style="font-size:8px; margin-top:2px;">PRONTO</span>
        </div>

        <div id="stats-panel" class="hidden">
            <h3 style="margin:0 0 10px 0; text-align:center; font-size:12px; color:#4da6ff;">STATUS</h3>
            <div>Vida MÃ¡x: <span id="stat-maxhp">100</span></div>
            <div>Dano Base: <span id="stat-dmg">10</span></div>
            <div>Vel. Ataque: <span id="stat-atkspd">1.00</span>/s</div>
            <div>Chance CrÃ­tico: <span id="stat-critc">5</span>%</div>
            <div>Dano CrÃ­tico: <span id="stat-critd">200</span>%</div>
            <div>Roubo de Vida: <span id="stat-lifesteal">0</span>%</div>
            <div style="font-size:8px;color:#aaa; justify-content:flex-end;">(MÃ¡x 2% HP)</div>
        </div>

        <div id="hud-top-right">
            <div id="souls-container">
                <span id="souls-label">Almas</span>: <span id="souls-text">0</span>
            </div>
            <button id="pause-btn-ingame" onclick="audioManager.playWav('botton'); game.togglePause()">PAUSE (ESC)</button>
        </div>
        <div id="wave-display">WAVE 1</div>
        
        <button id="perk-list-btn" onclick="audioManager.playWav('botton'); togglePerkModal()">PERKS</button>
        <button id="stats-btn" onclick="audioManager.playWav('botton'); document.getElementById('stats-panel').classList.toggle('hidden');">STATS</button>
    </div>

    <div id="dev-console" class="hidden">
        <input type="text" id="dev-input" placeholder="> Comando (/wave 15, /perk catalyst)" autocomplete="off" />
    </div>

    <div id="perk-modal" class="hidden">
        <h3 id="perk-modal-title" style="text-align:center; margin-top:0;">PERKS COLETADOS</h3>
        <p style="text-align:center; font-size:8px; color:#666; margin-bottom:10px;">(Clique em um perk para ver a descriÃ§Ã£o)</p>
        <div id="perk-list-content"></div>
        <button class="btn" onclick="audioManager.playWav('botton'); togglePerkModal()" style="margin-top:10px; padding: 5px 10px;" id="btn-close-perks">FECHAR</button>
    </div>

    <div id="audio-controls">
        <button id="mute-btn" class="btn" onclick="audioManager.playWav('botton'); audioManager.toggleMute()" style="padding: 5px; font-size: 10px; border:none; width: 30px;">ðŸ”Š</button>
        <input type="range" id="volume-slider" min="0" max="1" step="0.1" value="0.5" oninput="audioManager.setVolume(this.value)">
    </div>

    <div id="main-menu" class="menu-screen">
        <div class="lang-select">
            <button class="flag-btn active" id="lang-pt" onclick="audioManager.playWav('botton'); setLanguage('pt')">ðŸ‡§ðŸ‡· PT-BR</button>
            <button class="flag-btn" id="lang-en" onclick="audioManager.playWav('botton'); setLanguage('en')">ðŸ‡ºðŸ‡¸ EN-US</button>
        </div>
        <h1>Archmage's Greed</h1>
        <div class="char-select-container" id="char-selection"></div>
        <button class="btn" id="btn-play" onclick="audioManager.playWav('botton'); startGameLocal()">SINGLEPLAYER</button>
        <button class="btn" id="btn-multiplayer" onclick="audioManager.playWav('botton'); showMultiplayerMenu()">MULTIPLAYER</button>
        <p id="controls-hint" style="font-size: 10px; color: #888; margin-top:20px;">Use A/D para Mover, EspaÃ§o p/ Pular, Mouse p/ Mirar, F p/ Habilidade</p>
        <div id="audio-hint">Clique para ativar o som</div>
    </div>

    <div id="multiplayer-menu" class="menu-screen hidden">
        <h2>MULTIPLAYER</h2>
        <button class="btn" onclick="audioManager.playWav('botton'); Net.initHost()">CRIAR SALA (HOST)</button>
        <div style="margin: 20px 0;">
            <input type="text" id="join-id-input" class="input-text" placeholder="Cole o ID da Sala">
            <br>
            <button class="btn" onclick="audioManager.playWav('botton'); Net.initClient(document.getElementById('join-id-input').value)">ENTRAR NA SALA</button>
        </div>
        <button class="btn" onclick="audioManager.playWav('botton'); document.getElementById('multiplayer-menu').classList.add('hidden'); document.getElementById('main-menu').classList.remove('hidden');" style="border-color:gray; color:gray">VOLTAR</button>
    </div>

    <div id="lobby-menu" class="menu-screen hidden">
        <h2>SALA DE ESPERA</h2>
        <p style="font-size: 10px; margin-bottom: 10px;">ID DA SALA: <span id="lobby-room-id" style="color:yellow;">Gerando...</span></p>
        
        <div id="server-status-container"></div>

        <div class="lobby-players">
            <div class="lobby-player-box" id="lobby-p1-box">
                <h3>HOST (P1)</h3>
                <img id="lobby-p1-img" src="Assets/mage1.png" width="64" height="64" style="margin:10px 0;">
                <p id="lobby-p1-status" style="color:gray">Aguardando...</p>
            </div>
            <div class="lobby-player-box" id="lobby-p2-box">
                <h3>CLIENTE (P2)</h3>
                <img id="lobby-p2-img" src="Assets/mage1.png" width="64" height="64" style="margin:10px 0; opacity:0.2;">
                <p id="lobby-p2-status" style="color:gray">Desconectado</p>
            </div>
        </div>

        <div class="char-select-container" id="lobby-char-selection"></div>
        
        <button class="btn" id="btn-lobby-ready" onclick="audioManager.playWav('botton'); Net.toggleReady()">PRONTO</button>
        <button class="btn hidden" id="btn-lobby-start" onclick="audioManager.playWav('botton'); Net.hostStartGame()" style="border-color:#4dff4d; color:#4dff4d">INICIAR JOGO</button>
    </div>

    <div id="upgrade-menu" class="menu-screen hidden">
        <h2 id="wave-complete-text">WAVE COMPLETE!</h2>
        <p id="choose-perk-text" style="font-size:12px; margin-bottom:10px; color:#ccc">Escolha um perk para avanÃ§ar</p>
        <div id="upgrade-container"></div>
        <div id="timer-bar-container"><div id="timer-bar"></div></div>
        <p id="timer-text" style="font-size:10px; margin-top:5px;">20s</p>
    </div>
    
    <div id="boss-confirm-menu" class="menu-screen hidden">
        <h1 id="boss-wave-title" style="color:#bf00ff">BOSS WAVE</h1>
        <p id="boss-warning-text" style="margin-bottom: 20px;">VocÃª estÃ¡ pronto?</p>
        <button class="btn" id="btn-start-boss" onclick="audioManager.playWav('botton'); confirmBossWave()">COMEÃ‡AR</button>
    </div>

    <div id="pause-menu" class="menu-screen hidden" style="background: rgba(0,0,0,0.8);">
        <h1 id="pause-title">PAUSADO</h1>
        <button class="btn" id="btn-resume" onclick="audioManager.playWav('botton'); game.togglePause()">CONTINUAR</button>
        <button class="btn" id="btn-giveup" onclick="audioManager.playWav('botton'); returnToMenu()" style="border-color: red; color: red;">DESISTIR</button>
    </div>

    <div id="game-over-menu" class="menu-screen hidden">
        <h1 id="game-over-title" style="color:red">VOCÃŠ MORREU</h1>
        <p><span id="stats-wave">Ondas</span>: <span id="final-wave">0</span></p>
        <p><span id="stats-souls">Almas</span>: <span id="final-souls">0</span></p>
        
        <button class="btn" id="btn-menu-sp" onclick="audioManager.playWav('botton'); returnToMenu()">MENU PRINCIPAL</button>
        
        <div id="mp-gameover-controls" class="hidden" style="display:flex; gap:20px; justify-content:center;">
            <button class="btn" id="btn-mp-restart" onclick="audioManager.playWav('botton'); Net.voteRestart()">REINICIAR (0/2)</button>
            <button class="btn" id="btn-mp-quit" onclick="audioManager.playWav('botton'); Net.disconnectAndMenu()" style="border-color:red; color:red;">SAIR DA SALA</button>
        </div>
        <p id="mp-restart-status" style="font-size:10px; color:#4dff4d; margin-top:10px; min-height:15px;"></p>
    </div>
</div>

<script>
/**
 * GLOBAL TIME SCALE & HELPERS
 */
window.timeScale = 1.0;

function distToSegmentSquared(p, v, w) {
    let l2 = (w.x - v.x)**2 + (w.y - v.y)**2;
    if (l2 === 0) return (p.x - v.x)**2 + (p.y - v.y)**2;
    let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    t = Math.max(0, Math.min(1, t));
    return (p.x - (v.x + t * (w.x - v.x)))**2 + (p.y - (v.y + t * (w.y - v.y)))**2;
}
function distToSegment(p, v, w) { return Math.sqrt(distToSegmentSquared(p, v, w)); }

// FunÃ§Ã£o para Escalonamento de Dano DinÃ¢mico dos Inimigos
function getEnemyBaseDamage(wave) {
    if (wave < 15) return 5 + (wave * (5/15)); // ComeÃ§a em 5, vai pra 10 na wave 15
    if (wave <= 20) return 10 + ((wave - 15) * (4/5)); // Vai pra 14 na wave 20
    if (wave <= 25) return 14 + ((wave - 20) * (6/5)); // Vai pra ~20 na wave 25
    return 20 + ((wave - 25) * 2.5); // Escala mais rÃ¡pido apÃ³s a wave 25
}

/**
 * LOCALIZAÃ‡ÃƒO
 */
let currentLang = 'pt';
const TEXTS = {
    pt: {
        play: "JOGAR", controls: "Use A/D p/ Mover, EspaÃ§o p/ Pular, Mouse p/ Mirar, F p/ Habilidade", waveComplete: "ONDA CONCLUÃDA!", choosePerk: "Escolha um perk para avanÃ§ar",
        bossWave: "CHEFE", miniBoss: "MINI CHEFE", ready: "VocÃª estÃ¡ pronto?", start: "COMEÃ‡AR", paused: "PAUSADO", resume: "CONTINUAR", giveUp: "DESISTIR",
        gameOver: "FIM DE JOGO", waves: "Ondas", souls: "Almas", menu: "MENU", perksTitle: "PERKS COLETADOS", close: "FECHAR", blocked: "BLOQUEADO",
        revived: "RENASCEU!", perks: "PERKS", shield: "[ESCUDO]", phoenix: "[FENIX]", acquired: "Adquirido", tier: "NÃ­vel"
    },
    en: {
        play: "PLAY", controls: "Use A/D to Move, Space to Jump, Mouse to Aim, F for Skill", waveComplete: "WAVE COMPLETE!", choosePerk: "Choose a perk to advance",
        bossWave: "BOSS WAVE", miniBoss: "MINI BOSS", ready: "Are you sure?", start: "START", paused: "PAUSED", resume: "RESUME", giveUp: "GIVE UP",
        gameOver: "GAME OVER", waves: "Waves Survived", souls: "Souls Earned", menu: "MAIN MENU", perksTitle: "COLLECTED PERKS", close: "CLOSE", blocked: "BLOCKED",
        revived: "REVIVED!", perks: "PERKS", shield: "[SHIELD]", phoenix: "[PHOENIX]", acquired: "Acquired", tier: "Tier"
    }
};

function setLanguage(lang) {
    currentLang = lang;
    document.getElementById('lang-pt').classList.toggle('active', lang === 'pt');
    document.getElementById('lang-en').classList.toggle('active', lang === 'en');
    
    const t = TEXTS[lang];
    document.getElementById('btn-play').innerText = t.play;
    document.getElementById('controls-hint').innerText = t.controls;
    document.getElementById('wave-complete-text').innerText = t.waveComplete;
    document.getElementById('choose-perk-text').innerText = t.choosePerk;
    document.getElementById('boss-warning-text').innerText = t.ready;
    document.getElementById('btn-start-boss').innerText = t.start;
    document.getElementById('pause-title').innerText = t.paused;
    document.getElementById('btn-resume').innerText = t.resume;
    document.getElementById('btn-giveup').innerText = t.giveUp;
    document.getElementById('game-over-title').innerText = t.gameOver;
    document.getElementById('stats-wave').innerText = t.waves;
    document.getElementById('stats-souls').innerText = t.souls;
    document.getElementById('btn-menu').innerText = t.menu;
    document.getElementById('perk-modal-title').innerText = t.perksTitle;
    document.getElementById('btn-close-perks').innerText = t.close;
    document.getElementById('perk-list-btn').innerText = t.perks;
    document.getElementById('mana-shield-indicator').innerText = t.shield;
    document.getElementById('phoenix-indicator').innerText = t.phoenix;
    document.getElementById('souls-label').innerText = t.souls;
}

/**
 * ASSETS E ÃUDIO
 */
const ASSETS = { 
    images: { 
        mage1: new Image(), mage2: new Image(), mage3: new Image(),
        triangulo: new Image(), losango: new Image(), redondo: new Image(),
        miniboss: new Image(), boss: new Image()
    }, 
    audio: { main: new Audio(), principal: new Audio(), boss: new Audio(), botton: new Audio(), bossdefeat: new Audio() } 
};
ASSETS.images.mage1.src = 'Assets/mage1.png'; ASSETS.images.mage2.src = 'Assets/mage2.png'; ASSETS.images.mage3.src = 'Assets/mage3.png';
ASSETS.images.triangulo.src = 'Assets/triangulo.png'; ASSETS.images.losango.src = 'Assets/losango.png'; ASSETS.images.redondo.src = 'Assets/redondo.png';
ASSETS.images.miniboss.src = 'Assets/miniboss.png'; ASSETS.images.boss.src = 'Assets/boss.png';

ASSETS.audio.main.src = 'Assets/Main.wav'; ASSETS.audio.main.loop = true;
ASSETS.audio.principal.src = 'Assets/Principal.wav'; ASSETS.audio.principal.loop = true;
ASSETS.audio.boss.src = 'Assets/Boss.wav'; ASSETS.audio.boss.loop = true;
ASSETS.audio.botton.src = 'Assets/botton.wav';
ASSETS.audio.bossdefeat.src = 'Assets/bossdefeat.wav';

const audioManager = {
    current: null, context: null, isMuted: false, 
    globalVolume: parseFloat(localStorage.getItem('gameVolume') !== null ? localStorage.getItem('gameVolume') : 0.5),
    
    init() {
        if (!this.context) this.context = new (window.AudioContext || window.webkitAudioContext)();
        if (this.context.state === 'suspended') this.context.resume();
    },
    setVolume(val) {
        this.globalVolume = parseFloat(val);
        localStorage.setItem('gameVolume', this.globalVolume);
        if (this.current) this.current.volume = this.globalVolume;
    },
    toggleMute() {
        this.isMuted = !this.isMuted;
        document.getElementById('mute-btn').innerText = this.isMuted ? 'ðŸ”‡' : 'ðŸ”Š';
        ASSETS.audio.main.muted = this.isMuted; ASSETS.audio.principal.muted = this.isMuted; ASSETS.audio.boss.muted = this.isMuted;
    },
    play(trackName) {
        this.init();
        if (this.current === ASSETS.audio[trackName] && !this.current.paused) return;
        if (this.current) { this.current.pause(); this.current.currentTime = 0; }
        if (ASSETS.audio[trackName]) {
            this.current = ASSETS.audio[trackName];
            this.current.volume = this.globalVolume;
            this.current.play().catch(e => console.log("Aguardando interaÃ§Ã£o..."));
        }
    },
    playWav(trackName) {
        if (this.isMuted) return;
        this.init();
        if (ASSETS.audio[trackName]) {
            const snd = ASSETS.audio[trackName].cloneNode();
            snd.volume = this.globalVolume;
            snd.play().catch(e => {});
        }
    },
    playSfx(type) {
        if (this.isMuted) return;
        this.init();
        const ctx = this.context; const osc = ctx.createOscillator(); const gain = ctx.createGain();
        osc.connect(gain); gain.connect(ctx.destination);
        const now = ctx.currentTime; const vol = this.globalVolume; 
        
        if (type === 'shoot') {
            osc.type = 'square'; osc.frequency.setValueAtTime(300 + Math.random() * 100, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
            gain.gain.setValueAtTime(0.03 * vol, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1); osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'hit') {
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(150, now); gain.gain.setValueAtTime(0.05 * vol, now); gain.gain.linearRampToValueAtTime(0, now + 0.1); osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'shatter') { 
            osc.type = 'triangle'; osc.frequency.setValueAtTime(800, now); osc.frequency.linearRampToValueAtTime(100, now + 0.05);
            gain.gain.setValueAtTime(0.02 * vol, now); gain.gain.linearRampToValueAtTime(0, now + 0.05); osc.start(now); osc.stop(now + 0.05);
        } else if (type === 'select') {
            osc.type = 'sine'; osc.frequency.setValueAtTime(600 + Math.random() * 300, now); gain.gain.setValueAtTime(0.05 * vol, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1); osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'thunder') {
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(50, now); osc.frequency.linearRampToValueAtTime(20, now + 0.3);
            gain.gain.setValueAtTime(0.2 * vol, now); gain.gain.linearRampToValueAtTime(0, now + 0.3); osc.start(now); osc.stop(now + 0.3);
        } else if (type === 'boss_die') {
            osc.type = 'square'; osc.frequency.setValueAtTime(100, now); osc.frequency.linearRampToValueAtTime(10, now + 1.0);
            gain.gain.setValueAtTime(0.3 * vol, now); gain.gain.linearRampToValueAtTime(0, now + 1.0); osc.start(now); osc.stop(now + 1.0);
        } else if (type === 'phoenix') {
            osc.type = 'triangle'; osc.frequency.setValueAtTime(200, now); osc.frequency.linearRampToValueAtTime(800, now + 0.5);
            gain.gain.setValueAtTime(0.2 * vol, now); gain.gain.linearRampToValueAtTime(0, now + 0.5); osc.start(now); osc.stop(now + 0.5);
        } else if (type === 'laser') {
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.linearRampToValueAtTime(80, now + 0.2);
            gain.gain.setValueAtTime(0.04 * vol, now); gain.gain.linearRampToValueAtTime(0.01, now + 0.2); osc.start(now); osc.stop(now + 0.2);
        } else if (type === 'teleport') {
            osc.type = 'sine'; osc.frequency.setValueAtTime(100, now); osc.frequency.exponentialRampToValueAtTime(800, now + 1.0);
            gain.gain.setValueAtTime(0.15 * vol, now); gain.gain.linearRampToValueAtTime(0, now + 1.0); osc.start(now); osc.stop(now + 1.0);
        }
    }
};

/**
 * CONFIGURAÃ‡Ã•ES GERAIS
 */
const CONFIG = {
    gravity: 0.28, friction: 0.8, playerSpeed: 1.5, jumpForce: 8.8, 
    baseEnemyHP: 20, bossWaveInterval: 10, miniBossInterval: 5,
    colors: { bg: '#000', player: '#fff', enemy: '#ccc', boss: '#eee', bullet: '#fff' }
};

/**
 * CACHE SYSTEM PARA PERFORMANCE
 */
const ObjectPool = {
    bullets: [], enemies: [], particles: [],

    getBullet(x, y, angle, damage, isPlayer, stats) {
        if (this.bullets.length > 0) { let b = this.bullets.pop(); b.reset(x, y, angle, damage, isPlayer, stats); return b; }
        return new Projectile(x, y, angle, damage, isPlayer, stats);
    },
    releaseBullet(b) { this.bullets.push(b); },

    getEnemy(x, y, type) {
        if (this.enemies.length > 0) { let e = this.enemies.pop(); e.reset(x, y, type); return e; }
        return new Enemy(x, y, type);
    },
    releaseEnemy(e) { this.enemies.push(e); },

    getParticle(x, y, color, size, duration, speedMult = 1) {
        if (this.particles.length > 0) { let p = this.particles.pop(); p.reset(x, y, color, size, duration, speedMult); return p; }
        return new Particle(x, y, color, size, duration, speedMult);
    },
    releaseParticle(p) { this.particles.push(p); }
};


/**
 * REDE & MULTIPLAYER (WebRTC / PeerJS)
 * ConfiguraÃ§Ã£o com teste de latÃªncia e seleÃ§Ã£o automÃ¡tica de servidores
 */
const RAW_ICE_SERVERS = [
    // Google STUNs (RÃ¡pidos)
    { name: "Google STUN 1", urls: "stun:stun.l.google.com:19302" },
    { name: "Google STUN 2", urls: "stun:stun1.l.google.com:19302" },
    
    // Cloudflare TURN (Suas credenciais)
    {
        name: "Cloudflare TCP (Port 5349)",
        urls: "turns:turn.cloudflare.com:5349?transport=tcp",
        username: "g0824e083e4309e817208621651613629786c075f562aeff3e4376594295de75",
        credential: "a6df968770ec3b486e54f8884672a7334ec30314715fb35ce6d412a0ebd333b3="
    },
    {
        name: "Cloudflare UDP (Port 3478)",
        urls: "turn:turn.cloudflare.com:3478?transport=udp",
        username: "a6df968770ec3b486e54f8884672a7334ec30314715fb35ce6d412a0ebd333b3",
        credential: "g0824e083e4309e817208621651613629786c075f562aeff3e4376594295de75"
    },

    // Metered / OpenRelay
    {
        name: "OpenRelay TCP",
        urls: "turn:openrelay.metered.ca:443?transport=tcp",
        username: "openrelayproject",
        credential: "openrelayproject"
    },
    {
        name: "OpenRelay UDP",
        urls: "turn:openrelay.metered.ca:80",
        username: "openrelayproject",
        credential: "openrelayproject"
    },

    // Metered Direto
    {
        name: "Metered/Coturn UDP",
        urls: "turn:192.158.29.39:3478?transport=udp",
        username: "28224511:1379330808",
        credential: "JZEOEt2V3Qb0y27GRntt2u2PAYA="
    },
    {
        name: "Metered/Coturn TCP",
        urls: "turn:192.158.29.39:3478?transport=tcp",
        username: "28224511:1379330808",
        credential: "JZEOEt2V3Qb0y27GRntt2u2PAYA="
    },

    // Legado / Outros
    {
        name: "Numb Viagenie",
        urls: "turn:numb.viagenie.ca",
        username: "webrtc@live.com",
        credential: "muazkh"
    },
    {
        name: "AnyFirewall TCP",
        urls: "turn:turn.anyfirewall.com:443?transport=tcp",
        username: "webrtc",
        credential: "webrtc"
    }
];

const Net = {
    isOnline: false,
    isHost: false,
    peer: null,
    conn: null,
    
    // Status do Lobby
    p1Char: 1, p2Char: 1,
    p1Ready: false, p2Ready: false,
    
    // Controle de VotaÃ§Ã£o
    myVote: false,
    remoteVote: false,

    generateId() {
        return Math.random().toString(36).substring(2, 6).toUpperCase();
    },

    // --- FUNÃ‡ÃƒO DE PING (Mede latÃªncia WebRTC) ---
    async measureLatency(iceConfig) {
        return new Promise((resolve) => {
            const start = Date.now();
            const timeout = 2500; // 2.5s timeout mÃ¡ximo por servidor
            
            const pc = new RTCPeerConnection({ iceServers: [iceConfig], iceTransportPolicy: 'all' });
            pc.createDataChannel("ping");

            let resolved = false;

            pc.onicecandidate = (e) => {
                if (e.candidate && !resolved) {
                    const ping = Date.now() - start;
                    resolved = true;
                    pc.close();
                    resolve(ping);
                }
            };

            pc.createOffer().then(o => pc.setLocalDescription(o));

            setTimeout(() => {
                if (!resolved) {
                    resolved = true;
                    pc.close();
                    resolve(9999); // Timeout (Infinito)
                }
            }, timeout);
        });
    },

    // --- ATUALIZA A UI VISUALMENTE ---
    updateServerUI(results) {
        const container = document.getElementById('server-status-container');
        container.style.display = 'block';
        container.innerHTML = '<div style="text-align:center; margin-bottom:5px; color:#fff; border-bottom:1px solid #fff;">TESTE DE CONEXÃƒO</div>';

        results.sort((a, b) => a.ping - b.ping); // Ordena do melhor para o pior

        results.forEach(res => {
            const row = document.createElement('div');
            row.className = 'server-row';
            
            let colorClass = 'ping-bad';
            let statusText = 'OFFLINE';

            if (res.ping < 9999) {
                statusText = res.ping + 'ms';
                if (res.ping < 150) colorClass = 'ping-good';
                else if (res.ping < 500) colorClass = 'ping-ok';
            }

            if (res === results[0] && res.ping < 9999) {
                statusText += ' (SELECIONADO)';
                row.style.background = 'rgba(77, 255, 77, 0.2)';
            }

            row.innerHTML = `
                <span style="color:#ccc">${res.name}</span>
                <span class="${colorClass}">${statusText}</span>
            `;
            container.appendChild(row);
        });
    },

    async initHost() {
        console.log("%c[HOST] Iniciando testes de rede...", "color: cyan");
        if (this.peer) this.peer.destroy();

        this.isHost = true;
        this.isOnline = true;
        document.getElementById('multiplayer-menu').classList.add('hidden');
        document.getElementById('lobby-menu').classList.remove('hidden');
        
        const lobbyText = document.getElementById('lobby-room-id');
        lobbyText.innerText = "Testando servidores...";
        lobbyText.style.color = "cyan";

        document.getElementById('server-status-container').style.display = 'block';
        document.getElementById('server-status-container').innerHTML = '<p class="ping-loading" style="text-align:center">Testando latÃªncia...</p>';

        // 1. Executa testes de ping em paralelo
        const results = await Promise.all(RAW_ICE_SERVERS.map(async (server) => {
            const ping = await this.measureLatency(server);
            return { ...server, ping };
        }));

        // 2. Filtra servidores mortos e ordena pelos melhores
        const bestServers = results.filter(s => s.ping < 9999).sort((a, b) => a.ping - b.ping);
        this.updateServerUI(results);

        if (bestServers.length === 0) {
            lobbyText.innerText = "Erro: Nenhum servidor!";
            lobbyText.style.color = "red";
            return;
        }

        // 3. Monta configuraÃ§Ã£o com os 3 melhores TURNs + Google STUNs (Backup)
        const finalIceServers = [
            ...bestServers.slice(0, 3), 
            { urls: "stun:stun.l.google.com:19302" } 
        ];

        console.log("Melhores servidores escolhidos:", finalIceServers);
        lobbyText.innerText = "Iniciando Peer...";

        const config = {
            debug: 2,
            config: {
                iceServers: finalIceServers,
                iceCandidatePoolSize: 10
            }
        };

        try {
            this.peer = new Peer(this.generateId(), config);
        } catch (e) {
            console.error("Erro fatal PeerJS:", e);
            lobbyText.innerText = "Erro Fatal";
            return;
        }
        
        this.peer.on('open', id => {
            console.log(`[HOST] ID Criado: ${id}`);
            lobbyText.innerText = id;
            lobbyText.style.color = "yellow";
            this.updateLobbyUI();
        });
        
        this.setupPeerEvents();
    },

    initClient(targetId) {
        if (!targetId) { alert("Digite o ID!"); return; }
        
        // Cliente usa uma lista genÃ©rica robusta, pois nÃ£o faz o teste visual
        const clientIceList = RAW_ICE_SERVERS; 

        console.log("%c[CLIENT] Conectando...", "color: orange");
        if (this.peer) this.peer.destroy();

        this.isHost = false;
        this.isOnline = true;
        document.getElementById('multiplayer-menu').classList.add('hidden');
        document.getElementById('lobby-menu').classList.remove('hidden');
        document.getElementById('lobby-room-id').innerText = "Conectando...";
        document.getElementById('server-status-container').style.display = 'none';

        const config = {
            debug: 2,
            config: { iceServers: clientIceList }
        };

        this.peer = new Peer(config);

        this.peer.on('open', id => {
            this.conn = this.peer.connect(targetId.trim().toUpperCase(), {
                reliable: true, serialization: 'json'
            });
            this.handleClientConnection(targetId);
        });
        
        this.peer.on('error', err => {
            document.getElementById('lobby-room-id').innerText = "Erro: " + err.type;
        });
    },

    setupPeerEvents() {
        this.peer.on('connection', c => {
            if (this.conn && this.conn.open) { c.close(); return; }
            this.conn = c;
            console.log("Cliente conectando...");
            
            this.conn.on('open', () => {
                console.log("âœ… ConexÃ£o estabelecida!");
                document.getElementById('lobby-room-id').style.color = "#4dff4d";
                this.setupConn();
                this.updateLobbyUI();
                setTimeout(() => {
                    this.send({ type: 'LOBBY', p1Char: this.p1Char, p1Ready: this.p1Ready });
                }, 500);
            });
            
            this.conn.on('close', () => {
                document.getElementById('lobby-room-id').style.color = "red";
                this.updateLobbyUI();
            });
        });

        this.peer.on('error', err => {
            console.error(err);
            document.getElementById('lobby-room-id').innerText = "Erro: " + err.type;
        });
    },

    handleClientConnection(targetId) {
        const timer = setTimeout(() => {
            if (!this.conn.open) {
                document.getElementById('lobby-room-id').innerText = "Tempo Esgotado";
                document.getElementById('lobby-room-id').style.color = "red";
            }
        }, 15000);

        this.conn.on('open', () => {
            clearTimeout(timer);
            console.log("âœ… Conectado!");
            document.getElementById('lobby-room-id').innerText = "Conectado: " + targetId;
            document.getElementById('lobby-room-id').style.color = "#4dff4d";
            this.setupConn();
            this.updateLobbyUI();
            this.send({ type: 'LOBBY', p2Char: this.p2Char, p2Ready: this.p2Ready });
        });

        this.conn.on('close', () => {
            alert("Desconectado.");
            location.reload();
        });
        
        this.conn.on('error', err => console.error("Erro conexÃ£o:", err));
    },

    setupConn() {
        this.conn.on('data', data => {
            if (data.type === 'PING') { this.send({ type: 'PONG' }); return; }

            if (data.type === 'LOBBY') {
                if (data.p1Char !== undefined) this.p1Char = data.p1Char;
                if (data.p2Char !== undefined) this.p2Char = data.p2Char;
                if (data.p1Ready !== undefined) this.p1Ready = data.p1Ready;
                if (data.p2Ready !== undefined) this.p2Ready = data.p2Ready;
                
                if (data.start) startGame(this.p1Char, this.p2Char);
                else this.updateLobbyUI();
            }
            if (data.type === 'INPUT' && this.isHost) {
                if (game) {
                    game.netInput.keys = data.input.keys;
                    game.netInput.mouse = data.input.mouse;
                    if(data.input.cmdLaser) game.player2.activateLaser();
                    if(data.input.cmdTeleport) game.player2.activateTeleport();
                }
            }
            if (data.type === 'STATE' && !this.isHost) {
                if (game && (game.state === 'PLAYING' || game.state === 'UPGRADE_MENU' || game.state === 'BOSS_CONFIRM' || game.state === 'BOSS_DEATH_CINEMATIC')) {
                    game.syncState(data.state);
                }
            }
            if (data.type === 'PICK_PERK') {
                if (this.isHost && game) {
                    game.p2PickedPerk = data.perkId;
                    game.checkMultiplayerPerks();
                }
            }
            if (data.type === 'GAME_OVER') {
                game.state = 'GAME_OVER';
                this.showMultiplayerGameOver();
            }
            if (data.type === 'NEXT_WAVE') {
                game.wave = data.wave;
                game.handleRevives();
                document.getElementById('upgrade-menu').classList.add('hidden');
            }
            if (data.type === 'BOSS_START') {
                document.getElementById('boss-confirm-menu').classList.add('hidden');
                game.triggerConfirmedBossWave();
            }
            if (data.type === 'BOSS_CONFIRM_READY') {
                if (this.isHost && game) {
                    game.p2BossReady = true;
                    game.checkBossStart();
                }
            }
            if (data.type === 'DEV_CMD') {
                if (this.isHost && game) {
                    game.processDevCommand(data.cmd, false);
                }
            }
            // --- NOVOS EVENTOS DE RESTART ---
            if (data.type === 'RESTART_VOTE') {
                this.remoteVote = true;
                this.updateRestartUI();
                this.checkRestartCondition();
            }
            if (data.type === 'RESTART_GAME') {
                game.hardReset();
            }
        });
    },

    send(data) {
        if (this.conn && this.conn.open) {
            try { this.conn.send(data); } catch(e) { console.error(e); }
        }
    },

    toggleReady() {
        if (this.isHost) this.p1Ready = !this.p1Ready; else this.p2Ready = !this.p2Ready;
        this.send({ type: 'LOBBY', p1Char: this.p1Char, p2Char: this.p2Char, p1Ready: this.p1Ready, p2Ready: this.p2Ready });
        this.updateLobbyUI();
    },

    setChar(charId) {
        if (this.isHost) this.p1Char = charId; else this.p2Char = charId;
        this.send({ type: 'LOBBY', p1Char: this.p1Char, p2Char: this.p2Char, p1Ready: this.p1Ready, p2Ready: this.p2Ready });
        this.updateLobbyUI();
    },

    updateLobbyUI() {
        const p1Status = document.getElementById('lobby-p1-status');
        const p2Status = document.getElementById('lobby-p2-status');
        const p1Img = document.getElementById('lobby-p1-img');
        const p2Img = document.getElementById('lobby-p2-img');
        const btnStart = document.getElementById('btn-lobby-start');

        p1Img.src = `Assets/mage${this.p1Char}.png`;
        p2Img.src = `Assets/mage${this.p2Char}.png`;

        if (this.p1Ready) { p1Status.innerText = "PRONTO"; p1Status.style.color = "#4dff4d"; }
        else { p1Status.innerText = "Aguardando..."; p1Status.style.color = "gray"; }

        if (this.conn && this.conn.open) {
            p2Img.style.opacity = 1;
            if (this.p2Ready) { p2Status.innerText = "PRONTO"; p2Status.style.color = "#4dff4d"; }
            else { p2Status.innerText = "Aguardando..."; p2Status.style.color = "gray"; }
        } else {
            p2Img.style.opacity = 0.2;
            p2Status.innerText = "Desconectado"; p2Status.style.color = "gray";
        }

        if (this.isHost && this.p1Ready && this.p2Ready && this.conn && this.conn.open) {
            btnStart.classList.remove('hidden');
        } else {
            btnStart.classList.add('hidden');
        }
    },

    hostStartGame() {
        if (!this.isHost) return;
        this.send({ type: 'LOBBY', start: true });
        startGame(this.p1Char, this.p2Char);
    },

    sendInputCmd(cmd) {
        if (!this.isHost && this.isOnline) {
            this.send({
                type: 'INPUT',
                input: {
                    keys: game.input.keys,
                    mouse: game.input.mouse,
                    cmdLaser: cmd === 'laser',
                    cmdTeleport: cmd === 'teleport'
                }
            });
        }
    },

    // --- FUNÃ‡Ã•ES DE RESTART (UI e LÃ³gica) ---
    showMultiplayerGameOver() {
        document.getElementById('final-wave').innerText = game.wave;
        document.getElementById('final-souls').innerText = game.souls;
        
        const menu = document.getElementById('game-over-menu');
        menu.classList.remove('hidden');
        
        document.getElementById('btn-menu-sp').classList.add('hidden');
        document.getElementById('mp-gameover-controls').classList.remove('hidden');
        document.getElementById('mp-gameover-controls').style.display = 'flex';
        
        this.myVote = false;
        this.remoteVote = false;
        this.updateRestartUI();
    },

    voteRestart() {
        if (this.myVote) return; 
        this.myVote = true;
        
        const btn = document.getElementById('btn-mp-restart');
        btn.style.borderColor = 'gray';
        btn.style.color = 'gray';
        btn.innerText = "AGUARDANDO...";
        
        this.send({ type: 'RESTART_VOTE' });
        this.updateRestartUI();
        this.checkRestartCondition();
    },

    updateRestartUI() {
        const votes = (this.myVote ? 1 : 0) + (this.remoteVote ? 1 : 0);
        const btn = document.getElementById('btn-mp-restart');
        
        if (!this.myVote) btn.innerText = `REINICIAR (${votes}/2)`;
        
        const status = document.getElementById('mp-restart-status');
        if (this.remoteVote && !this.myVote) status.innerText = "O outro jogador quer reiniciar!";
        else if (this.myVote && !this.remoteVote) status.innerText = "Esperando o outro jogador...";
        else if (votes === 2) status.innerText = "Reiniciando...";
        else status.innerText = "";
    },

    checkRestartCondition() {
        if (this.myVote && this.remoteVote) {
            if (this.isHost) {
                setTimeout(() => {
                    this.send({ type: 'RESTART_GAME' });
                    game.hardReset();
                }, 1000);
            }
        }
    },

    disconnectAndMenu() {
        if (this.conn) this.conn.close();
        if (this.peer) this.peer.destroy();
        location.reload();
    }
};


/**
 * UPGRADES DATA 
 */
const maxTierCheck = (p, id, max) => (p.perksCounts[id] || 0) >= max;

const UPGRADES_DB = {
    common: [
        { id: 'pursuing_orb', name_en: 'Pursuing Orb', name_pt: 'Orbe Perseguidora', max: 3, desc_en: 'Orb automatically shoots enemies.', desc_pt: 'Orbe que atira nos inimigos automaticamente.', apply: (p) => p.perks.pursuingOrb++ },
        { id: 'catalyst', name_en: 'Catalyst', name_pt: 'Catalisador', max: 99, desc_en: 'Damage +20%.', desc_pt: 'Dano +20%.', apply: (p) => p.stats.damage *= 1.2 },
        { id: 'eyesight', name_en: 'Eyesight', name_pt: 'VisÃ£o AguÃ§ada', max: 5, desc_en: 'Crit Chance +5%.', desc_pt: 'Chance CrÃ­tica +5%.', apply: (p) => p.stats.critChance += 0.05 },
        { id: 'growth', name_en: 'Growth', name_pt: 'Crescimento', max: 99, desc_en: 'Max HP +10.', desc_pt: 'Vida MÃ¡xima +10.', apply: (p) => { p.maxHp += 10; p.hp += 10; p.updateHpUI(); } },
        { id: 'impulse', name_en: 'Impulse', name_pt: 'Impulso', max: 99, desc_en: 'Jump Height +30%.', desc_pt: 'Altura do Pulo +30%.', apply: (p) => p.stats.jumpPower *= 1.3 },
        { id: 'renew', name_en: 'Renew', name_pt: 'Renovar', max: 99, desc_en: 'Full Heal.', desc_pt: 'Cura vida completamente.', apply: (p) => { p.hp = p.maxHp; p.updateHpUI(); } },
        { id: 'resist', name_en: 'Resist', name_pt: 'ResistÃªncia', max: 99, desc_en: 'Defense +4%.', desc_pt: 'Defesa +4%.', apply: (p) => p.stats.defense += 0.04 },
        { id: 'resonance', name_en: 'Resonance', name_pt: 'RessonÃ¢ncia', max: 3, desc_en: 'Atk Speed +12%.', desc_pt: 'Velocidade de Ataque +12%.', apply: (p) => p.stats.fireRate *= 0.88 },
        { id: 'souls', name_en: 'Souls', name_pt: 'Almas', max: 99, desc_en: 'Soul drop +1%.', desc_pt: 'Chance de Almas +1%.', apply: (p) => p.stats.soulChance += 0.01 },
        { id: 'stability', name_en: 'Ricochet', name_pt: 'Ricochete', max: 3, desc_en: '30%/50%/100% chance to bounce to nearby enemy.', desc_pt: '30%/50%/100% chance de ricochetear p/ outro inimigo.', apply: (p) => p.perks.chainLightning++ },
        { id: 'swift', name_en: 'Swift', name_pt: 'Veloz', max: 3, desc_en: 'Move Speed +10% (Stacks 3x).', desc_pt: 'Velocidade de Movimento +10% (Acumula 3x).', apply: (p) => p.perks.swift++ },
        { id: 'leech', name_en: 'Leech', name_pt: 'Sanguessuga', max: 1, desc_en: 'Heal 5% of kill dmg (Max 2% HP)', desc_pt: 'Cura 5% do dano ao matar (Max 2% HP)', apply: (p) => p.stats.lifesteal = 0.05 }
    ],
    uncommon: [
        { id: 'catalyst_plus', name_en: 'Catalyst+', name_pt: 'Catalisador+', max: 99, desc_en: 'Damage +40%.', desc_pt: 'Dano +40%.', apply: (p) => p.stats.damage *= 1.4 },
        { id: 'charge', name_en: 'Charge', name_pt: 'Carga', max: 99, desc_en: 'Projectile Size +20%.', desc_pt: 'Tamanho do ProjÃ©til +20%.', apply: (p) => p.stats.projSize *= 1.2 },
        { id: 'fragmentation', name_en: 'Fragmentation', name_pt: 'FragmentaÃ§Ã£o', max: 1, desc_en: 'Enemies explode into fragments.', desc_pt: 'Inimigos explodem em fragmentos.', apply: (p) => p.perks.fragmentation = true },
        { id: 'gush', name_en: 'Gush', name_pt: 'Jato', max: 99, desc_en: '+1 Double Jump.', desc_pt: '+1 Pulo Duplo.', apply: (p) => p.stats.jumpsMax += 1 },
        { id: 'luck', name_en: 'Luck', name_pt: 'Sorte', max: 99, desc_en: 'Better RNG.', desc_pt: 'Melhor RNG (Sorte).', apply: (p) => game.luck += 0.2 },
        { id: 'precision', name_en: 'Precision', name_pt: 'PrecisÃ£o', max: 2, desc_en: 'Crit Dmg +20%.', desc_pt: 'Dano CrÃ­tico +20%.', apply: (p) => p.stats.critDmg += 0.2 },
        { id: 'resonance_plus', name_en: 'Resonance+', name_pt: 'RessonÃ¢ncia+', max: 3, desc_en: 'Atk Speed +24%.', desc_pt: 'Velocidade de Ataque +24%.', apply: (p) => p.stats.fireRate *= 0.76 },
        { id: 'shrink', name_en: 'Shrink', name_pt: 'Encolher', max: 99, desc_en: 'Player Size -10%.', desc_pt: 'Tamanho do Mago -10%.', apply: (p) => { p.width *= 0.9; p.height *= 0.9; } },
        { id: 'swift_plus', name_en: 'Swift+', name_pt: 'Veloz+', max: 99, desc_en: 'Move Speed +40% (Rare).', desc_pt: 'Velocidade de Movimento +40% (Raro).', apply: (p) => p.stats.speed *= 1.4 },
        { id: 'thunderbolt', name_en: 'Lightning Bolt', name_pt: 'Raio', max: 3, desc_en: 'Lightning strikes periodic enemies.', desc_pt: 'Raios atingem inimigos periodicamente.', apply: (p) => p.perks.thunderbolt++ },
        { id: 'homing', name_en: 'Homing Missiles', name_pt: 'MÃ­sseis Teleguiados', max: 3, desc_en: 'Shots seek frontal targets.', desc_pt: 'Tiros travam em inimigos Ã  frente.', apply: (p) => p.perks.homing++ },
        { id: 'timewarp', name_en: 'Time Warp', name_pt: 'Dobra Temporal', max: 3, desc_en: 'Enemies slow 10%/15%/20%.', desc_pt: 'Inimigos lentos 10%/15%/20%.', apply: (p) => p.perks.timeWarp++ },
        { id: 'multishot', name_en: 'Multishot', name_pt: 'Tiro MÃºltiplo', max: 1, desc_en: '20% chance extra shot.', desc_pt: '20% chance de tiro extra.', apply: (p) => p.perks.multishot = true },
        { id: 'cold', name_en: 'Cold', name_pt: 'Gelo', max: 1, desc_en: 'Slows enemy fire rate (Stacks).', desc_pt: 'LentidÃ£o no tiro inimigo (Acumula).', apply: (p) => p.perks.cold = true },
        { id: 'execute', name_en: 'Execute', name_pt: 'Executar', max: 1, desc_en: '2x Dmg if enemy < 15% HP.', desc_pt: '2x Dano se inimigo < 15% HP.', apply: (p) => p.perks.execute = true },
        { id: 'bouncing', name_en: 'Bouncing Bolt', name_pt: 'Parede ElÃ¡stica', max: 1, desc_en: 'Shots bounce off walls 1x.', desc_pt: 'Tiros quicam na parede 1x.', apply: (p) => p.perks.bouncing = true },
        { id: 'manashield', name_en: 'Mana Shield', name_pt: 'Escudo de Mana', max: 1, desc_en: 'Blocks 1 hit (20s cd).', desc_pt: 'Bloqueia 1 hit (20s recarga).', apply: (p) => { p.perks.manaShield = true; p.manaShieldReady = true; document.getElementById('mana-shield-indicator').style.display='block'; } },
        { id: 'leech_plus', name_en: 'Leech+', name_pt: 'Sanguessuga+', max: 1, desc_en: 'Heal 10% of kill dmg (Max 2% HP)', desc_pt: 'Cura 10% do dano ao matar (Max 2% HP)', apply: (p) => p.stats.lifesteal = 0.10 },
        { id: 'poison', name_en: 'Toxic Bloom', name_pt: 'Veneno', max: 3, desc_en: 'Chance to poison enemies (5s duration).', desc_pt: 'Chance de envenenar inimigos (5s de duraÃ§Ã£o).', apply: (p) => p.perks.poison++ }
    ],
    epic: [
        { id: 'growth_plus_plus', name_en: 'Growth++', name_pt: 'Crescimento++', max: 99, desc_en: 'Max HP +40.', desc_pt: 'Vida MÃ¡xima +40.', apply: (p) => { p.maxHp += 40; p.hp += 40; p.updateHpUI(); } },
        { id: 'leech_plus_plus', name_en: 'Leech++', name_pt: 'Sanguessuga++', max: 1, desc_en: 'Heal 15% of kill dmg (Max 2% HP)', desc_pt: 'Cura 15% do dano ao matar (Max 2% HP)', apply: (p) => p.stats.lifesteal = 0.15 },
        { id: 'decimator', name_en: 'Decimator Laser', name_pt: 'Raio Dizimador', max: 3, desc_en: 'Fires a thick laser for 4s (180s CD).', desc_pt: 'Dispara um laser poderoso por 4s (180s CD).', apply: (p) => p.perks.decimator++ }
    ],
    legendary: [
         { id: 'phoenix', name_en: 'Phoenix Feather', name_pt: 'Pena de FÃªnix', max: 1, desc_en: 'Revive with 40% HP & nuke enemies.', desc_pt: 'Revive com 40% HP e frita inimigos.', apply: (p) => { p.perks.phoenix = true; document.getElementById('phoenix-indicator').style.display='block'; } },
         { id: 'teleport', name_en: 'Teleporter', name_pt: 'Teleporte', max: 1, desc_en: 'Teleport to opposite side (300s CD).', desc_pt: 'Teleporta ao lado oposto (300s recarga).', apply: (p) => { p.perks.teleport = true; document.getElementById('teleport-ui').style.display='flex'; } }
    ]
};

/**
 * GAME ENGINE
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let game; 

function togglePerkModal() {
    if (game && game.state === 'PLAYING') game.togglePause();
    const modal = document.getElementById('perk-modal');
    if (modal.classList.contains('hidden')) {
        updatePerkListUI();
        modal.classList.remove('hidden');
    } else {
        modal.classList.add('hidden');
    }
}

function updatePerkListUI() {
    const content = document.getElementById('perk-list-content');
    content.innerHTML = '';
    
    // Mostra os perks do jogador local
    let targetPlayer = null;
    if (game) {
        if (!Net.isOnline || Net.isHost) targetPlayer = game.player;
        else targetPlayer = game.player2; // Se for client on-line, o hud Ã© do p2
    }
    if (!targetPlayer) return;

    const counts = targetPlayer.perksCounts;
    for (let [id, count] of Object.entries(counts)) {
        if (count === 0) continue;
        const allPerks = [...UPGRADES_DB.common, ...UPGRADES_DB.uncommon, ...UPGRADES_DB.epic, ...UPGRADES_DB.legendary];
        const perkObj = allPerks.find(p => p.id === id);
        let perkName = id;
        if (perkObj) perkName = (currentLang === 'pt') ? perkObj.name_pt : perkObj.name_en;

        const row = document.createElement('div');
        row.className = 'perk-entry';
        let valText = perkObj && perkObj.max > 3 ? `x${count}` : `${TEXTS[currentLang].tier} ${count}`;
        if (perkObj && perkObj.max === 1) valText = TEXTS[currentLang].acquired;
        
        let descText = (currentLang === 'pt') ? perkObj.desc_pt : perkObj.desc_en;

        row.innerHTML = `<div class="header"><span>${perkName}</span><span>${valText}</span></div>
                         <div class="perk-desc hidden">${descText}</div>`;
        
        row.onclick = () => {
            const desc = row.querySelector('.perk-desc');
            desc.classList.toggle('hidden');
            audioManager.playWav('botton');
        };
        content.appendChild(row);
    }
}

class Game {
    constructor() {
        this.state = 'MENU';
        this.width = canvas.width;
        this.height = canvas.height;
        this.wave = 1;
        this.souls = parseInt(localStorage.getItem('savedSouls') || 0);
        this.luck = 1.0;
        this.upgradeChoices = 5;
        this.paused = false;
        
        this.player = null;
        this.player2 = null; // Para Multiplayer
        
        this.bullets = [];
        this.enemies = [];
        this.particles = [];
        this.lightningEffects = [];
        this.floatingTexts = []; 
        
        this.blocks = [
            { x: 0, y: 490, w: 100, h: 200 },     
            { x: 100, y: 570, w: 100, h: 120 },   
            { x: 200, y: 650, w: 1072, h: 40 },    
            { x: 1272, y: 570, w: 100, h: 120 },  
            { x: 1372, y: 490, w: 100, h: 200 }   
        ];

        this.enemiesToSpawn = 0;
        this.lastSpawnTime = Date.now();
        this.lastThunderTime = Date.now();
        
        this.waveClusterX = this.width / 2;
        this.menuTimer = null; 
        this.manaShieldPausedTime = 0; 
        
        this.input = { keys: {}, mouse: { x: 0, y: 0 } };
        this.netInput = { keys: {}, mouse: { x: 0, y: 0 }, cmdLaser: false, cmdTeleport: false };

        this.p1PickedPerk = null;
        this.p2PickedPerk = null;

        // NOVO: Sistema de morte assimÃ©trica + revive
        this.deadThisWave = { p1: false, p2: false };
        this.reviveNextWave = { p1: false, p2: false };

        this.p1BossReady = false;
        this.p2BossReady = false;

        this.cinematicBoss = null;
        this.cinematicStartTime = 0;
        this.cinematicExplosionDone = false;
        this.showTeleportZonesUntil = 0;

        this.initInput();
        this.updateSoulsUI();
    }

    initInput() {
        window.addEventListener('keydown', e => {
            if(document.activeElement === document.getElementById('dev-input')) {
                if(e.code === 'Enter') {
                    this.processDevCommand(document.getElementById('dev-input').value);
                    document.getElementById('dev-console').classList.add('hidden');
                    canvas.focus();
                }
                return;
            }

            if (e.code === 'Enter') {
                const devCon = document.getElementById('dev-console');
                const devIn = document.getElementById('dev-input');
                if (devCon.classList.contains('hidden')) {
                    devCon.classList.remove('hidden');
                    devIn.value = '';
                    devIn.focus();
                    this.input.keys = {}; 
                }
            }
            if (e.code === 'Escape') {
                audioManager.playWav('botton');
                this.togglePause();
            }
            if (e.code === 'KeyF' && this.state === 'PLAYING') {
                if (!Net.isOnline || Net.isHost) {
                    if (this.player) this.player.activateLaser();
                } else {
                    Net.sendInputCmd('laser');
                }
            }
            if (e.code === 'KeyT' && this.state === 'PLAYING') {
                if (!Net.isOnline || Net.isHost) {
                    if (this.player) this.player.activateTeleport();
                } else {
                    Net.sendInputCmd('teleport');
                }
            }
            this.input.keys[e.code] = true;
        });
        window.addEventListener('keyup', e => this.input.keys[e.code] = false);
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            this.input.mouse.x = e.clientX - rect.left;
            this.input.mouse.y = e.clientY - rect.top;
        });
        
        const unlockAudio = () => {
            audioManager.init();
            if (this.state === 'MENU' || this.state === 'GAME_OVER') audioManager.play('main');
            document.getElementById('audio-hint').style.display = 'none';
            window.removeEventListener('click', unlockAudio);
        };
        window.addEventListener('click', unlockAudio);
    }

processDevCommand(cmd, isHostCmd = true) {
        if(!cmd || !cmd.startsWith('/')) return;
        
        if (Net.isOnline && !Net.isHost) {
            Net.send({ type: 'DEV_CMD', cmd: cmd });
            return;
        }

        let targetPlayer = isHostCmd ? this.player : this.player2;
        const parts = cmd.trim().split(' ');
        
        if (parts[0] === '/wave' && parts[1]) {
            this.wave = parseInt(parts[1]);
            this.enemies.forEach(e => e.dead = true);
            this.enemiesToSpawn = 0;
            this.state = 'PLAYING';
            this.addFloatingText(this.width/2, this.height/2, `PULANDO PARA WAVE ${this.wave}`, "yellow");
            this.startWave();
        } else if (parts[0] === '/perk' && parts[1]) {
            const perkId = parts[1];
            const allPerks = [...UPGRADES_DB.common, ...UPGRADES_DB.uncommon, ...UPGRADES_DB.epic, ...UPGRADES_DB.legendary];
            
            if (perkId === 'all') {
                if (targetPlayer) {
                    allPerks.forEach(pObj => {
                        let currentCount = targetPlayer.perksCounts[pObj.id] || 0;
                        let missing = pObj.max - currentCount;
                        if (missing > 3 && pObj.max > 10) missing = 3; 
                        for(let i=0; i < missing; i++){
                            pObj.apply(targetPlayer);
                            targetPlayer.perksCounts[pObj.id] = (targetPlayer.perksCounts[pObj.id] || 0) + 1;
                        }
                    });
                    if (isHostCmd) targetPlayer.updateStatsUI();
                    this.addFloatingText(targetPlayer.x, targetPlayer.y - 40, `+ALL PERKS MAXED`, "#4dff4d");
                }
            } else {
                const pObj = allPerks.find(p => p.id === perkId);
                if (pObj && targetPlayer) {
                    pObj.apply(targetPlayer);
                    targetPlayer.perksCounts[pObj.id] = (targetPlayer.perksCounts[pObj.id] || 0) + 1;
                    if (isHostCmd) targetPlayer.updateStatsUI();
                    this.addFloatingText(targetPlayer.x, targetPlayer.y - 40, `+${perkId}`, "#4dff4d");
                }
            }
        }
    }

    togglePause() {
        if (this.state !== 'PLAYING' && this.state !== 'PAUSED') return;

        let targetP = (!Net.isOnline || Net.isHost) ? this.player : this.player2;

        if (this.state === 'PLAYING') {
            this.state = 'PAUSED';
            this.paused = true;
            document.getElementById('pause-menu').classList.remove('hidden');
            if (targetP && !targetP.manaShieldReady && targetP.perks.manaShield) {
                this.manaShieldPausedTime = targetP.manaShieldCooldown - Date.now();
            }
        } else {
            this.state = 'PLAYING';
            this.paused = false;
            document.getElementById('pause-menu').classList.add('hidden');
            if (targetP && !targetP.manaShieldReady && targetP.perks.manaShield) {
                targetP.manaShieldCooldown = Date.now() + this.manaShieldPausedTime;
            }
        }
    }

    start(char1, char2) {
        this.state = 'PLAYING';
        this.paused = false;
        
        let startX = Net.isOnline ? (this.width/2 - 50) : this.width/2;
        
        this.player = new Player(startX, this.height - 150, char1, true); // P1 local pro Host / Fake pro Client
        if (Net.isOnline) {
            this.player2 = new Player(startX + 100, this.height - 150, char2, false); 
        }

        this.bullets = []; this.enemies = []; this.particles = []; this.lightningEffects = []; this.floatingTexts = [];
        this.wave = 1;
        document.getElementById('teleport-ui').style.display = 'none';
        
        if (!Net.isOnline || Net.isHost) {
            this.startWave();
        }
    }

  startWave() {
        const isBoss = (this.wave % CONFIG.bossWaveInterval === 0 || this.wave % CONFIG.miniBossInterval === 0);
        if (isBoss) {
            this.state = 'BOSS_CONFIRM';
            const title = (this.wave % CONFIG.bossWaveInterval === 0) ? TEXTS[currentLang].bossWave : TEXTS[currentLang].miniBoss;
            document.getElementById('boss-wave-title').innerText = title;
            document.getElementById('boss-wave-title').style.color = (this.wave % CONFIG.bossWaveInterval === 0) ? 'red' : '#bf00ff';
            document.getElementById('boss-confirm-menu').classList.remove('hidden');
            // Agora aparece para os dois jogadores
        } else {
            let baseSpawns = 2 + (this.wave * 1);
            if (this.player && this.player.perks.thunderbolt === 3) baseSpawns = Math.floor(baseSpawns * 1.3);
            if (Net.isOnline) baseSpawns = Math.floor(baseSpawns * 1.5);

            this.enemiesToSpawn = baseSpawns;
            
            this.lastSpawnTime = Date.now();
            this.waveClusterX = 200 + Math.random() * (this.width - 400);
            audioManager.play('principal');
            this.showWaveText(`WAVE ${this.wave}`);
        }
    }

    triggerConfirmedBossWave() {
        this.state = 'PLAYING';
        
        // --- CORREÃ‡ÃƒO: ForÃ§a o menu a sumir visualmente para o Host ---
        const bossMenu = document.getElementById('boss-confirm-menu');
        if (!bossMenu.classList.contains('hidden')) {
            bossMenu.classList.add('hidden');
        }
        
        // Reseta o botÃ£o para a prÃ³xima vez que aparecer (cosmÃ©tico)
        const btn = document.getElementById('btn-start-boss');
        btn.innerText = "COMEÃ‡AR";
        btn.disabled = false;
        // -------------------------------------------------------------

        audioManager.play('boss');
        this.enemiesToSpawn = 0; 
        
        if (!Net.isOnline || Net.isHost) {
            this.spawnBoss(this.wave % CONFIG.bossWaveInterval === 0);
        }
        
        const title = (this.wave % CONFIG.bossWaveInterval === 0) ? TEXTS[currentLang].bossWave : TEXTS[currentLang].miniBoss;
        this.showWaveText(title);
        
        if (Net.isOnline && Net.isHost) Net.send({ type: 'BOSS_START' });
    }

    checkBossStart() {
        if (this.p1BossReady && this.p2BossReady) {
            this.p1BossReady = false;
            this.p2BossReady = false;
            this.triggerConfirmedBossWave();
        }
    }
    
    startBossDeathCinematic(boss) {
        this.state = 'BOSS_DEATH_CINEMATIC';
        this.cinematicBoss = boss;
        this.cinematicStartTime = Date.now();
        this.cinematicExplosionDone = false;
        
        if (audioManager.current) audioManager.current.pause();
        audioManager.playWav('bossdefeat');
    }

    startTeleport(fromLeft) {
        this.state = 'TELEPORTING';
        let fadeElement = document.getElementById('teleport-fade');
        fadeElement.style.display = 'block';
        
        setTimeout(() => fadeElement.style.opacity = 1, 10);
        audioManager.playSfx('teleport');

        setTimeout(() => {
            // Move Players
            this.player.x = fromLeft ? this.width - 150 : 100;
            this.player.y = 50;
            this.player.vy = 0;
            
            if (this.player2) {
                this.player2.x = fromLeft ? this.width - 250 : 200;
                this.player2.y = 50;
                this.player2.vy = 0;
            }
            
            // Move Todos os Inimigos
            this.enemies.forEach(e => {
                let newX = fromLeft ? 50 + Math.random() * 150 : this.width - 200 - Math.random() * 150;
                newX = Math.max(0, Math.min(this.width - e.width, newX));
                e.x = newX;
                if (e.anchorX !== undefined) e.anchorX = newX;
            });

            fadeElement.style.opacity = 0;
            setTimeout(() => {
                fadeElement.style.display = 'none';
                this.state = 'PLAYING';
            }, 700);
        }, 700);
    }

    createExplosion(x, y, color, count, baseSize, baseSpeed, duration) {
        for(let i = 0; i < count; i++) {
            if (this.particles.length >= 2000) break; 
            let p = ObjectPool.getParticle(x, y, color, baseSize + Math.random() * (baseSize * 0.5), duration);
            let angle = Math.random() * Math.PI * 2;
            let speed = baseSpeed + Math.random() * (baseSpeed * 0.8);
            
            p.vx = Math.cos(angle) * speed;
            p.vy = Math.sin(angle) * speed;
            
            this.particles.push(p);
        }
    }

    triggerCinematicExplosions() {
        if (!this.cinematicBoss) return;
        this.cinematicBoss.dead = true;
        
        this.createExplosion(
            this.cinematicBoss.x + this.cinematicBoss.width / 2, 
            this.cinematicBoss.y + this.cinematicBoss.height / 2, 
            '#bf00ff', 80, 12, 8, 2000
        );
        
        this.enemies.forEach(e => {
            if (e !== this.cinematicBoss && !e.dead) {
                e.dead = true;
                this.createExplosion(e.x + e.width / 2, e.y + e.height / 2, 'white', 12, 6, 5, 1500);
            }
        });

        if (!this.cinematicBoss.isBigBoss) this.souls += 10; else this.souls += 30;
        this.updateSoulsUI();
    }

    endCinematic() {
        this.state = 'UPGRADE_MENU';
        window.timeScale = 1.0;
        this.enemies = []; 
        document.getElementById('fade-overlay').style.opacity = 0;
        audioManager.play('principal');
        
        let targetP = (!Net.isOnline || Net.isHost) ? this.player : this.player2;
        if (targetP && !targetP.manaShieldReady && targetP.perks.manaShield) {
            this.manaShieldPausedTime = targetP.manaShieldCooldown - Date.now();
        }

        if (!Net.isOnline || Net.isHost) {
            this.p1PickedPerk = null;
            this.p2PickedPerk = null;
        }

        this.showUpgradeMenu();
    }

    showWaveText(text) {
        const el = document.getElementById('wave-display');
        el.innerText = text; el.style.opacity = 1;
        setTimeout(() => { el.style.opacity = 0; }, 3000);
    }

    updateSoulsUI() {
        document.getElementById('souls-text').innerText = this.souls;
        document.getElementById('final-souls').innerText = this.souls;
        localStorage.setItem('savedSouls', this.souls);
    }

    clearAllBullets() {
        for (let i = this.bullets.length - 1; i >= 0; i--) {
            ObjectPool.releaseBullet(this.bullets[i]);
        }
        this.bullets = [];
    }

    // MULTIPLAYER SYNC
serializeState() {
        if (!this.player) {
            return { st: this.state, wv: this.wave, so: this.souls || 0 };
        }
        const p1OrbX = this.player.orb ? this.player.orb.x : this.player.x + this.player.width / 2;
        const p1OrbY = this.player.orb ? this.player.orb.y : this.player.y + this.player.height / 2;
        const p2OrbX = (this.player2 && this.player2.orb) ? this.player2.orb.x : (this.player2 ? this.player2.x + this.player2.width / 2 : 0);
        const p2OrbY = (this.player2 && this.player2.orb) ? this.player2.orb.y : (this.player2 ? this.player2.y + this.player2.height / 2 : 0);

        return {
            st: this.state,
            wv: this.wave,
            so: this.souls,
            tpz: this.showTeleportZonesUntil,
            p1: { 
                x: this.player.x, 
                y: this.player.y, 
                w: this.player.width,   // <- Novo: altura e largura pro Shrink nÃ£o bugar
                h: this.player.height, 
                hp: this.player.hp, 
                mx: this.player.maxHp, 
                la: this.player.laserActive, 
                fa: this.player.facing, 
                ms: this.player.manaShieldReady, 
                or: p1OrbX, 
                oy: p1OrbY, 
                iu: this.player.invulnUntil,
                wt: this.player.walkTimer,
                d: this.player.isDead
            },
            p2: this.player2 ? {
                x: this.player2.x, 
                y: this.player2.y, 
                w: this.player2.width, 
                h: this.player2.height, 
                hp: this.player2.hp, 
                mx: this.player2.maxHp, 
                la: this.player2.laserActive, 
                fa: this.player2.facing, 
                ms: this.player2.manaShieldReady, 
                or: p2OrbX, 
                oy: p2OrbY, 
                iu: this.player2.invulnUntil,
                wt: this.player2.walkTimer,
                d: this.player2.isDead
            } : null,
            en: this.enemies.map(e => ({ x: e.x, y: e.y, hp: e.hp, mx: e.maxHp, t: e.type, s: e.shieldActive, po: e.poisonActive, w: e.width, h: e.height, lh: e.lastHitTime, isB: e.isBigBoss || false, aX: e.anchorX, cU: e.colorUntil })),
            bu: this.bullets.map(b => ({ x: b.x, y: b.y, c: b.color, r: b.radius, hi: b.history || [] })),
            pa: this.particles.map(p => ({ x: p.x, y: p.y, c: p.color, s: p.size })),
            ft: this.floatingTexts.map(f => ({ x: f.x, y: f.y, t: f.text, c: f.color, d: f.duration, st: f.spawnTime })),
            le: this.lightningEffects.map(l => ({ x: l.x, y: l.y, t: l.isThick, d: l.duration, st: l.spawnTime }))
        };
    }

    syncState(s) {
        if (!s) return;

        // ForÃ§a o Client a abrir a tela de escolha de perks
        if (this.state !== 'UPGRADE_MENU' && s.st === 'UPGRADE_MENU') {
            this.showUpgradeMenu();
        }
        if (this.state === 'UPGRADE_MENU' && s.st === 'PLAYING') {
            document.getElementById('upgrade-menu').classList.add('hidden');
        }
        
        // ForÃ§a o Client a ver a tela de Boss caso o Host ative
        if (this.state !== 'BOSS_CONFIRM' && s.st === 'BOSS_CONFIRM') {
            const title = (s.wv % CONFIG.bossWaveInterval === 0) ? TEXTS[currentLang].bossWave : TEXTS[currentLang].miniBoss;
            document.getElementById('boss-wave-title').innerText = title;
            document.getElementById('boss-wave-title').style.color = (s.wv % CONFIG.bossWaveInterval === 0) ? 'red' : '#bf00ff';
            document.getElementById('boss-confirm-menu').classList.remove('hidden');
        }
        if (this.state === 'BOSS_CONFIRM' && s.st === 'PLAYING') {
            document.getElementById('boss-confirm-menu').classList.add('hidden');
        }

        this.state = s.st || this.state;
        this.wave = s.wv || this.wave;
        this.souls = s.so || this.souls;
        this.showTeleportZonesUntil = s.tpz || 0;

        if (this.player && s.p1) {
            this.player.x = s.p1.x; this.player.y = s.p1.y;
            if (s.p1.w) this.player.width = s.p1.w;
            if (s.p1.h) this.player.height = s.p1.h;
            this.player.hp = s.p1.hp; this.player.maxHp = s.p1.mx;
            this.player.laserActive = s.p1.la; this.player.facing = s.p1.fa;
            this.player.manaShieldReady = s.p1.ms; this.player.invulnUntil = s.p1.iu;
            if (this.player.orb && s.p1.or !== undefined) {
                this.player.orb.x = s.p1.or;
                this.player.orb.y = s.p1.oy;
            }
        }

        if (this.player2 && s.p2) {
            this.player2.x = s.p2.x; this.player2.y = s.p2.y;
            if (s.p2.w) this.player2.width = s.p2.w;
            if (s.p2.h) this.player2.height = s.p2.h;
            this.player2.hp = s.p2.hp; this.player2.maxHp = s.p2.mx;
            this.player2.laserActive = s.p2.la; this.player2.facing = s.p2.fa;
            this.player2.manaShieldReady = s.p2.ms; this.player2.invulnUntil = s.p2.iu;
            if (this.player2.orb && s.p2.or !== undefined) {
                this.player2.orb.x = s.p2.or;
                this.player2.orb.y = s.p2.oy;
            }
        }

        if (this.player2) this.player2.updateHpUI();
        this.updateSoulsUI();

        while(this.enemies.length < s.en.length) this.enemies.push(new Enemy(0,0,'redondo'));
        while(this.enemies.length > s.en.length) this.enemies.pop();
        for(let i=0; i<s.en.length; i++){
             this.enemies[i].x = s.en[i].x; this.enemies[i].y = s.en[i].y;
             this.enemies[i].hp = s.en[i].hp; this.enemies[i].maxHp = s.en[i].mx;
             this.enemies[i].type = s.en[i].t; this.enemies[i].shieldActive = s.en[i].s;
             this.enemies[i].poisonActive = s.en[i].po; this.enemies[i].width = s.en[i].w;
             this.enemies[i].height = s.en[i].h; this.enemies[i].lastHitTime = s.en[i].lh;
             this.enemies[i].isBigBoss = s.en[i].isB;
             this.enemies[i].anchorX = s.en[i].aX; this.enemies[i].colorUntil = s.en[i].cU;
        }

        while(this.bullets.length < s.bu.length) this.bullets.push(new Projectile(0,0,0,0,false));
        while(this.bullets.length > s.bu.length) this.bullets.pop();
        for(let i=0; i<s.bu.length; i++){
            this.bullets[i].x = s.bu[i].x; this.bullets[i].y = s.bu[i].y;
            this.bullets[i].radius = s.bu[i].r; this.bullets[i].color = s.bu[i].c;
            this.bullets[i].history = s.bu[i].hi || [];
        }

        while(this.particles.length < s.pa.length) this.particles.push(new Particle(0,0,'white',0));
        while(this.particles.length > s.pa.length) this.particles.pop();
        for(let i=0; i<s.pa.length; i++){
            this.particles[i].x = s.pa[i].x; this.particles[i].y = s.pa[i].y;
            this.particles[i].size = s.pa[i].s; this.particles[i].color = s.pa[i].c;
        }

        while(this.floatingTexts.length < s.ft.length) this.floatingTexts.push(new FloatingText(0,0,'',''));
        while(this.floatingTexts.length > s.ft.length) this.floatingTexts.pop();
        for(let i=0; i<s.ft.length; i++){
            this.floatingTexts[i].x = s.ft[i].x; this.floatingTexts[i].y = s.ft[i].y;
            this.floatingTexts[i].text = s.ft[i].t; this.floatingTexts[i].color = s.ft[i].c;
            this.floatingTexts[i].duration = s.ft[i].d; this.floatingTexts[i].spawnTime = s.ft[i].st;
        }

        while(this.lightningEffects.length < s.le.length) this.lightningEffects.push(new LightningBeam(0,0,false));
        while(this.lightningEffects.length > s.le.length) this.lightningEffects.pop();
        for(let i=0; i<s.le.length; i++){
            this.lightningEffects[i].x = s.le[i].x; this.lightningEffects[i].y = s.le[i].y;
            this.lightningEffects[i].isThick = s.le[i].t;
            this.lightningEffects[i].duration = s.le[i].d; this.lightningEffects[i].spawnTime = s.le[i].st;
        }
    }


    loop() {
        // ProteÃ§Ã£o: sÃ³ envia STATE se o player jÃ¡ existe
        // CORREÃ‡ÃƒO: Agora o Host envia o STATE tambÃ©m no UPGRADE_MENU para o Client abrir a tela
        if (Net.isOnline && Net.isHost && this.player && 
            (this.state === 'PLAYING' || this.state === 'BOSS_DEATH_CINEMATIC' || this.state === 'UPGRADE_MENU' || this.state === 'BOSS_CONFIRM')) {
            Net.send({ type: 'STATE', state: this.serializeState() });
        }

        if (!Net.isOnline || Net.isHost) {
            if ((this.state === 'PLAYING' || this.state === 'BOSS_DEATH_CINEMATIC') && !this.paused) {
                this.update();
                this.draw();
            } else {
                if (this.state !== 'MENU' && this.player) this.draw();
            }
        } else {
            if (this.state !== 'MENU' && this.state !== 'GAME_OVER' && this.state !== 'UPGRADE_MENU' && this.state !== 'BOSS_CONFIRM') {
                Net.send({ type: 'INPUT', input: { keys: this.input.keys, mouse: this.input.mouse } });
            }
            if (this.player) this.draw();
        }

        requestAnimationFrame(() => this.loop());
    }

    update() {
        if (!this.player) return;

        if (this.state === 'BOSS_DEATH_CINEMATIC') {
            window.timeScale = 0.2; 
            
            this.player.update(this.input);
            if (this.player2) this.player2.update(this.netInput);
            
            this.bullets.forEach(b => b.update());
            this.enemies.forEach(e => { if(!e.dead) e.update(this.enemies); });
            
            for (let i = this.particles.length - 1; i >= 0; i--) {
                let p = this.particles[i]; p.update();
                if (p.dead) { ObjectPool.releaseParticle(p); this.particles.splice(i, 1); }
            }
            for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
                let t = this.floatingTexts[i]; t.update();
                if (t.dead) this.floatingTexts.splice(i, 1);
            }
            
            let elapsed = Date.now() - this.cinematicStartTime;
            
            if (elapsed >= 3000 && !this.cinematicExplosionDone) {
                this.triggerCinematicExplosions();
                this.cinematicExplosionDone = true;
            }
            
            if (elapsed >= 3000) {
                let fadeProgress = (elapsed - 3000) / 2000;
                document.getElementById('fade-overlay').style.opacity = Math.min(1, fadeProgress);
            } else {
                document.getElementById('fade-overlay').style.opacity = 0;
            }
            
            if (elapsed >= 5000) {
                this.endCinematic();
            }
            
            return; 
        }

        window.timeScale = 1.0;
        document.getElementById('fade-overlay').style.opacity = 0;

        this.player.update(this.input);
        if (this.player2) this.player2.update(this.netInput);

        // Processa comando TP do P2
        if (Net.isOnline && Net.isHost && this.netInput.cmdTeleport) {
            this.player2.activateTeleport();
            this.netInput.cmdTeleport = false; // reset
        }
        if (Net.isOnline && Net.isHost && this.netInput.cmdLaser) {
            this.player2.activateLaser();
            this.netInput.cmdLaser = false; 
        }

        this.manageWaves();
        this.manageThunder();

        for (let i = this.bullets.length - 1; i >= 0; i--) {
            let b = this.bullets[i];
            b.update();
            if (b.dead) {
                ObjectPool.releaseBullet(b);
                this.bullets.splice(i, 1);
            }
        }

        for (let i = this.enemies.length - 1; i >= 0; i--) {
            let e = this.enemies[i];
            e.update(this.enemies);
            if (e.dead) {
                if (e.type !== 'boss' && e.type !== 'miniboss') ObjectPool.releaseEnemy(e);
                this.enemies.splice(i, 1);
                audioManager.playSfx('hit');
                // Almas dropam pro host, client recebe sync
                let p1Soul = Math.random() < this.player.stats.soulChance;
                let p2Soul = this.player2 ? (Math.random() < this.player2.stats.soulChance) : false;
                if (p1Soul || p2Soul) {
                    this.souls += 1;
                    this.updateSoulsUI();
                }
            }
        }

        for (let i = this.particles.length - 1; i >= 0; i--) {
            let p = this.particles[i];
            p.update();
            if (p.dead) {
                ObjectPool.releaseParticle(p);
                this.particles.splice(i, 1);
            }
        }

        for (let i = this.lightningEffects.length - 1; i >= 0; i--) {
            let l = this.lightningEffects[i];
            l.update();
            if (l.dead) this.lightningEffects.splice(i, 1);
        }
        
        for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
            let t = this.floatingTexts[i];
            t.update();
            if (t.dead) this.floatingTexts.splice(i, 1);
        }
    }
    manageThunder() {
        const checkThunder = (p) => {
            const tier = p.perks.thunderbolt;
            if (tier > 0) {
                let intervalSeconds = (tier === 3) ? 8 : Math.max(2, 6 - (tier - 1)); 
                if (Date.now() - p.lastThunderTime > intervalSeconds * 1000) {
                    const visibleEnemies = this.enemies.filter(e => e.y > 0 && e.y < this.height && e.x > 0 && e.x < this.width);
                    let boltsToFire = (tier === 3) ? 2 : 1;
                    let bossHitThisCycle = false;

                    for (let k = 0; k < boltsToFire; k++) {
                        let hit = false; let targetX, targetY; let targetEnemy = null;
                        let hitChance = tier === 1 ? 0.4 : (tier === 2 ? 0.5 : 0.8);

                        if (visibleEnemies.length > 0 && Math.random() < hitChance) {
                            targetEnemy = visibleEnemies[Math.floor(Math.random() * visibleEnemies.length)];
                            targetX = targetEnemy.x + targetEnemy.width/2; targetY = targetEnemy.y; hit = true;
                        } else {
                            targetX = 100 + Math.random() * (this.width - 200); targetY = 650; hit = false;
                        }

                        if (hit && targetEnemy) {
                            if (tier === 3) {
                                let hitCount = 0;
                                let nearEnemies = visibleEnemies.filter(e => Math.abs((e.x + e.width/2) - targetX) < 60 && !e.dead);
                                nearEnemies.sort((a,b) => Math.abs((a.x + a.width/2) - targetX) - Math.abs((b.x + b.width/2) - targetX));
                                
                                for(let ne of nearEnemies) {
                                    if(hitCount >= 2) break;
                                    if(ne.type === 'boss' || ne.type === 'miniboss') {
                                        if(!bossHitThisCycle) {
                                            ne.takeDamage(ne.maxHp * 0.07);
                                            bossHitThisCycle = true;
                                            hitCount++;
                                        }
                                    } else {
                                        ne.takeDamage(ne.hp + 10);
                                        hitCount++;
                                    }
                                }
                                targetY = game.height; 
                            } else {
                                let pctDmg = tier === 1 ? 0.6 : 0.8;
                                let bossPct = tier === 1 ? 0.05 : 0.08;
                                let mult = (targetEnemy.type === 'boss' || targetEnemy.type === 'miniboss') ? bossPct : pctDmg;
                                targetEnemy.takeDamage(targetEnemy.hp * mult);
                            }
                        }
                        this.lightningEffects.push(new LightningBeam(targetX, targetY, tier === 3));
                        audioManager.playSfx('thunder');
                    }
                    p.lastThunderTime = Date.now();
                }
            }
        };

        if (this.player) checkThunder(this.player);
        if (this.player2) checkThunder(this.player2);
    }
// CORREÃ‡ÃƒO: Nova funÃ§Ã£o dedicada a destravar o menu multiplayer
    checkMultiplayerPerks() {
        if (this.state === 'UPGRADE_MENU' && Net.isOnline && Net.isHost) {
            if (this.p1PickedPerk && this.p2PickedPerk) {
                this.applyPerkToPlayer(this.player, this.p1PickedPerk);
                if (this.player2) this.applyPerkToPlayer(this.player2, this.p2PickedPerk);

                document.getElementById('upgrade-menu').classList.add('hidden');
                if (this.menuTimer) clearInterval(this.menuTimer);

                this.handleRevives();

                this.player.updateStatsUI();
                if (this.player2) this.player2.updateStatsUI();

                this.p1PickedPerk = null;
                this.p2PickedPerk = null;

                this.wave++; this.state = 'PLAYING'; this.startWave();
                Net.send({ type: 'NEXT_WAVE', wave: this.wave });
            }
        }
    }

    manageWaves() {
        if (this.state === 'UPGRADE_MENU') {
            return; // LÃ³gica movida para o checkMultiplayerPerks
        }

        if (this.enemies.length === 0 && this.enemiesToSpawn <= 0) {
            this.state = 'UPGRADE_MENU';
            this.showUpgradeMenu(); 
        }
        if (this.enemiesToSpawn > 0) {
            if (Date.now() - this.lastSpawnTime > 1000) { 
                this.spawnEnemy(); this.enemiesToSpawn--; this.lastSpawnTime = Date.now();
            }
        }
    }

    applyPerkToPlayer(playerObj, perkId) {
        if (perkId === 'fallback_heal') {
            playerObj.hp = Math.min(playerObj.maxHp, playerObj.hp + 20);
            if((playerObj.isPlayer1 && Net.isHost) || (!playerObj.isPlayer1 && !Net.isHost) || !Net.isOnline) playerObj.updateHpUI();
            return;
        }
        const allPerks = [...UPGRADES_DB.common, ...UPGRADES_DB.uncommon, ...UPGRADES_DB.epic, ...UPGRADES_DB.legendary];
        const pObj = allPerks.find(p => p.id === perkId);
        if (pObj && playerObj) {
            pObj.apply(playerObj);
            playerObj.perksCounts[pObj.id] = (playerObj.perksCounts[pObj.id] || 0) + 1;
        }
    }

    handleRevives() {
        if (!Net.isOnline) return;

        if (this.reviveNextWave.p1 && this.player) {
            this.player.hp = this.player.maxHp * 0.60;
            this.player.updateHpUI();
            this.player.invulnUntil = Date.now() + 3000;
            game.addFloatingText(this.player.x + 20, this.player.y - 40, "RESSUSCITADO! (60%)", "#ffd700");
            this.reviveNextWave.p1 = false;
        }
        if (this.reviveNextWave.p2 && this.player2) {
            this.player2.hp = this.player2.maxHp * 0.60;
            this.player2.updateHpUI();
            this.player2.invulnUntil = Date.now() + 3000;
            game.addFloatingText(this.player2.x + 20, this.player2.y - 40, "RESSUSCITADO! (60%)", "#ffd700");
            this.reviveNextWave.p2 = false;
        }

        this.deadThisWave = { p1: false, p2: false };
    }

    spawnEnemy(forcedX = null) {
        const x = forcedX !== null ? forcedX : Math.max(0, Math.min(this.width - 50, this.waveClusterX - 120 + Math.random() * 240));
        const y = -50;
        
        const types = ['triangulo', 'losango', 'redondo'];
        let type = types[Math.floor(Math.random() * types.length)];
        
        this.enemies.push(ObjectPool.getEnemy(x, y, type));
    }

    spawnBoss(isBigBoss) { this.enemies.push(new Boss(this.width/2 - 40, -100, isBigBoss)); }

    createParticle(x, y, color, size, duration = 500, speedMult = 1) {
        if (this.particles.length >= 2000) return; 
        this.particles.push(ObjectPool.getParticle(x, y, color, size, duration, speedMult));
    }
    
    addFloatingText(x, y, text, color = null) {
        const colors = ['red', '#4da6ff', '#00ff00']; 
        const c = color || colors[Math.floor(Math.random() * colors.length)];
        this.floatingTexts.push(new FloatingText(x, y, text, c));
    }

    showUpgradeMenu() {
        this.clearAllBullets();

        const menu = document.getElementById('upgrade-menu');
        const container = document.getElementById('upgrade-container');
        container.innerHTML = '';
        menu.classList.remove('hidden');
        
        const cpText = document.getElementById('choose-perk-text');
        cpText.innerText = TEXTS[currentLang].choosePerk;

        // Timer sÃ³ roda no Host
        if (!Net.isOnline || Net.isHost) {
            let secondsLeft = 20;
            const timerText = document.getElementById('timer-text');
            const timerBar = document.getElementById('timer-bar');
            timerBar.style.width = '100%'; timerText.innerText = "20s";

            if (this.menuTimer) clearInterval(this.menuTimer);

            this.menuTimer = setInterval(() => {
                secondsLeft--;
                timerText.innerText = secondsLeft + "s";
                timerBar.style.width = (secondsLeft / 20 * 100) + "%";
                if (secondsLeft <= 0) {
                    clearInterval(this.menuTimer);
                    this.autoPickPerk();
                }
            }, 1000);
        }

        let targetP = (!Net.isOnline || Net.isHost) ? this.player : this.player2;
        
        let available = [];
        const addAvailable = (pool, rarity) => {
            pool.forEach(u => {
                if (!maxTierCheck(targetP, u.id, u.max)) available.push({ ...u, rarity });
            });
        };
        addAvailable(UPGRADES_DB.common, 'common');
        addAvailable(UPGRADES_DB.uncommon, 'uncommon');
        addAvailable(UPGRADES_DB.epic, 'epic');
        addAvailable(UPGRADES_DB.legendary, 'legendary');

        let choices = [];
        for(let i=0; i<3; i++) {
            if (available.length === 0) break;
            let idx = Math.floor(Math.random() * available.length);
            choices.push(available[idx]);
            available.splice(idx, 1);
        }

        if (choices.length === 0) {
            choices.push({ id: 'fallback_heal', name_pt: 'Cura Leve', name_en: 'Light Heal', desc_pt: 'Cura 20 HP', desc_en: 'Heals 20 HP', rarity: 'common' });
        }

        this.currentUpgradeChoices = choices; 

        choices.forEach(c => {
            let card = document.createElement('div');
            card.className = `upgrade-card rarity-${c.rarity}`;
            let title = currentLang === 'pt' ? (c.name_pt || c.id) : (c.name_en || c.id);
            let desc = currentLang === 'pt' ? (c.desc_pt || '') : (c.desc_en || '');

            card.innerHTML = `
                <span class="card-tier">${c.rarity.toUpperCase()}</span>
                <div class="card-title">${title}</div>
                <div class="card-desc">${desc}</div>
            `;
            card.onclick = () => {
                audioManager.playWav('botton');
                this.pickUpgrade(c.id);
                container.innerHTML = `<p style="color:#4da6ff; margin-top: 50px; font-size: 12px;">Aguardando outro jogador...</p>`;
            };
            container.appendChild(card);
        });
    }

    pickUpgrade(perkId) {
        if (!Net.isOnline) {
            this.applyPerkToPlayer(this.player, perkId);
            document.getElementById('upgrade-menu').classList.add('hidden');
            if (this.menuTimer) clearInterval(this.menuTimer);
            this.wave++;
            this.startWave();
        } else {
            if (Net.isHost) {
                this.p1PickedPerk = perkId;
                this.checkMultiplayerPerks(); // CORREÃ‡ÃƒO: Avisa que o Host escolheu!
            } else {
                Net.send({ type: 'PICK_PERK', perkId: perkId });
            }
        }
    }

    autoPickPerk() {
        if (!Net.isOnline) {
            if (this.currentUpgradeChoices && this.currentUpgradeChoices.length > 0) {
                this.pickUpgrade(this.currentUpgradeChoices[0].id);
            } else {
                this.pickUpgrade('fallback_heal');
            }
        } else {
            if (Net.isHost) {
                if (!this.p1PickedPerk) {
                    this.p1PickedPerk = (this.currentUpgradeChoices && this.currentUpgradeChoices.length > 0) ? this.currentUpgradeChoices[0].id : 'fallback_heal';
                }
                if (!this.p2PickedPerk) {
                    this.p2PickedPerk = 'fallback_heal'; 
                }
                this.checkMultiplayerPerks(); // CORREÃ‡ÃƒO: ForÃ§a a passagem de wave caso esgote o tempo
            }
        }
    }

    takeDamage(amount, isBossAttack = false) {
        if (this.isDead || Date.now() < this.invulnUntil) return;

        if (this.manaShieldReady) {
            this.manaShieldReady = false; this.manaShieldCooldown = Date.now() + 20000; 
            if((this.isPlayer1 && Net.isHost) || (!this.isPlayer1 && !Net.isHost) || !Net.isOnline) {
                document.getElementById('mana-shield-indicator').style.display='none';
            }
            game.addFloatingText(this.x, this.y - 20, TEXTS[currentLang].blocked, "#4dff4d");
            audioManager.playSfx('shatter'); this.invulnUntil = Date.now() + 3000; return;
        }

        let finalDamage = amount * (1 - this.stats.defense);
        const maxPctDamage = isBossAttack ? 0.20 : 0.15;
        const capLimit = this.maxHp * maxPctDamage;
        if (finalDamage > capLimit) finalDamage = capLimit;

        this.hp -= finalDamage; 
        
        if((this.isPlayer1 && Net.isHost) || (!this.isPlayer1 && !Net.isHost) || !Net.isOnline) {
            this.updateHpUI(); 
        }

        this.invulnUntil = Date.now() + 1000; 
        this.healingFatigueUntil = Date.now() + 4000;

        game.addFloatingText(this.x, this.y, Math.round(finalDamage));

        if (this.hp <= 0) {
            this.hp = 0;
            this.isDead = true;

            // SINGLEPLAYER MORTE
            if (!Net.isOnline) {
                game.state = 'GAME_OVER';
                document.getElementById('final-wave').innerText = game.wave;
                document.getElementById('game-over-menu').classList.remove('hidden');
                
                // Garante UI de Singleplayer
                document.getElementById('btn-menu-sp').classList.remove('hidden');
                document.getElementById('mp-gameover-controls').classList.add('hidden');
                
                audioManager.play('main');
                return;
            }

            // MULTIPLAYER - morte assimÃ©trica
            const isP1 = this.isPlayer1;
            game.deadThisWave[isP1 ? 'p1' : 'p2'] = true;

            // Se AMBOS morreram nesta wave
            if (game.deadThisWave.p1 && game.deadThisWave.p2) {
                game.state = 'GAME_OVER';
                audioManager.play('main');
                
                if (Net.isHost) {
                    Net.send({ type: 'GAME_OVER' });
                    Net.showMultiplayerGameOver(); // Chama UI do Host
                } else {
                    Net.showMultiplayerGameOver(); // Chama UI do Client localmente tambÃ©m se detectar
                }
                return;
            }

            // Se apenas UM morreu, avisa que vai reviver
            if ((this.isPlayer1 && Net.isHost) || (!this.isPlayer1 && !Net.isHost) || !Net.isOnline) {
                game.addFloatingText(this.x, this.y - 40, "MORREU - RESSUSCITA NA PRÃ“XIMA WAVE", "#ff4444");
            }
            game.reviveNextWave[isP1 ? 'p1' : 'p2'] = true;
        }
    }

    hardReset() {
        // Limpa UI
        document.getElementById('game-over-menu').classList.add('hidden');
        document.getElementById('btn-mp-restart').innerText = "REINICIAR (0/2)";
        document.getElementById('btn-mp-restart').style.borderColor = 'white';
        document.getElementById('btn-mp-restart').style.color = 'white';
        document.getElementById('mp-restart-status').innerText = "";
        
        // Reseta Variaveis
        this.wave = 1;
        this.souls = 0; 
        this.updateSoulsUI();
        
        this.enemies = [];
        this.bullets = [];
        this.particles = [];
        this.floatingTexts = [];
        this.deadThisWave = { p1: false, p2: false };
        this.reviveNextWave = { p1: false, p2: false };
        
        if (this.menuTimer) clearInterval(this.menuTimer);

        // Reseta Players
        let startX = Net.isOnline ? (this.width/2 - 50) : this.width/2;
        
        // Recria P1
        let char1 = this.player.charIndex; 
        this.player = new Player(startX, this.height - 150, char1, true);
        
        // Recria P2
        if (this.player2) {
            let char2 = this.player2.charIndex;
            this.player2 = new Player(startX + 100, this.height - 150, char2, false);
        }
        
        // Reseta Status Net
        Net.myVote = false;
        Net.remoteVote = false;
        
        // Inicia
        this.state = 'PLAYING';
        this.startWave();
        
        // Sincroniza estado inicial imediatamente
        if(Net.isHost) Net.send({ type: 'STATE', state: this.serializeState() });
    }

    draw(ctx) {
        if (this.isDead) return;
        if (Date.now() < this.invulnUntil && Math.floor(Date.now() / 100) % 2 === 0) return;
        if (this.manaShieldReady) {
            ctx.save(); ctx.globalAlpha = 0.3; ctx.fillStyle = '#4dff4d'; ctx.beginPath(); ctx.arc(this.x + this.width/2, this.y + this.height/2, 40, 0, Math.PI * 2); ctx.fill(); ctx.restore();
        }

        const imgKey = `mage${this.charIndex}`; const img = ASSETS.images[imgKey];
        let bobY = Math.sin(this.walkTimer) * 3;

        if (img && img.complete && img.naturalHeight !== 0) ctx.drawImage(img, this.x, this.y + bobY, this.width, this.height);
        else { ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y + bobY, this.width, this.height); }
        
        // Identificador Player Local x Remoto
        ctx.save();
        ctx.font = '8px "Press Start 2P"';
        ctx.fillStyle = this.isPlayer1 ? 'red' : 'blue';
        ctx.textAlign = 'center';
        let txt = "";
        if(!Net.isOnline) txt = "P1";
        else {
            if (Net.isHost) txt = this.isPlayer1 ? "VocÃª" : "P2";
            else txt = this.isPlayer1 ? "P1" : "VocÃª";
        }
        ctx.fillText(txt, this.x + this.width/2, this.y - 10 + bobY);
        ctx.restore();

        this.orb.draw(ctx);
    }
}

function returnToMenu() { location.reload(); }

function startGameLocal() {
    audioManager.playWav('botton');
    audioManager.play('principal'); 
    document.getElementById('hud-top-left').style.display = 'block'; 
    document.getElementById('pause-btn-ingame').style.display = 'block'; 
    document.getElementById('perk-list-btn').style.display = 'block'; 
    document.getElementById('stats-btn').style.display = 'block'; 
    document.getElementById('souls-container').style.opacity = '1';
    document.getElementById('main-menu').classList.add('hidden'); 
    Net.isOnline = false;
    game.start(window.selectedChar, 1);
}

function showMultiplayerMenu() {
    document.getElementById('main-menu').classList.add('hidden');
    document.getElementById('multiplayer-menu').classList.remove('hidden');
}

function startGame(c1, c2) {
    document.getElementById('lobby-menu').classList.add('hidden');
    document.getElementById('hud-top-left').style.display = 'block'; 
    document.getElementById('pause-btn-ingame').style.display = 'block'; 
    document.getElementById('perk-list-btn').style.display = 'block'; 
    document.getElementById('stats-btn').style.display = 'block'; 
    document.getElementById('souls-container').style.opacity = '1';
    
    audioManager.play('principal'); 
    game.start(c1, c2);
}

function confirmBossWave() { 
    // CORREÃ‡ÃƒO: Esconde o menu localmente primeiro para evitar flickering
    document.getElementById('boss-confirm-menu').classList.add('hidden');
    
    const btn = document.getElementById('btn-start-boss');
    btn.innerText = "AGUARDANDO...";
    btn.disabled = true;

    if (!Net.isOnline) {
        game.triggerConfirmedBossWave();
        // Reseta botÃ£o singleplayer
        btn.innerText = "COMEÃ‡AR";
        btn.disabled = false;
    } else {
        if (Net.isHost) {
            game.p1BossReady = true;
            console.log("[HOST] P1 pronto para o Boss.");
            game.checkBossStart();
        } else {
            console.log("[CLIENT] Enviando pronto para o Host.");
            Net.send({ type: 'BOSS_CONFIRM_READY' });
            // Reseta botÃ£o cosmeticamente
            setTimeout(() => {
                btn.innerText = "COMEÃ‡AR";
                btn.disabled = false;
            }, 2000);
        }
    }
}

function initGame() {
    localStorage.setItem('unlockedChars', '[1]');
    setLanguage('pt'); 
    game = new Game();
    document.getElementById('volume-slider').value = audioManager.globalVolume; 
    audioManager.play('main');
    
    // UI Local Singleplayer Selection
    const select = document.getElementById('char-selection');
    const chars = [{ id: 1, name: 'Default', cost: 0, unlocked: true }, { id: 2, name: 'Void', cost: 100, unlocked: false }, { id: 3, name: 'Crazy', cost: 200, unlocked: false }];
    const unlockedData = JSON.parse(localStorage.getItem('unlockedChars') || '[1]');
    
    chars.forEach((c, index) => {
        const isUnlocked = unlockedData.includes(c.id); const el = document.createElement('div');
        el.className = `char-card ${isUnlocked ? '' : 'char-locked'}`; if (index === 0) el.classList.add('selected');
        
        el.innerHTML = `<img src="Assets/mage${c.id}.png" style="width:64px;height:64px;display:block;margin:0 auto;object-fit:contain;" alt="Mage ${c.id}">
            <p>${c.name}</p>${!isUnlocked ? `<p style="color:#4da6ff;font-size:10px">${c.cost} Souls</p>` : ''}`;
            
        el.onclick = () => {
            audioManager.playWav('botton'); 
            if (audioManager.current && audioManager.current.paused) audioManager.play('main');
            if (isUnlocked) { document.querySelectorAll('.char-card').forEach(x => x.classList.remove('selected')); el.classList.add('selected'); window.selectedChar = c.id; } 
            else {
                if (game.souls >= c.cost) {
                    if(confirm(`Comprar ${c.name} por ${c.cost} almas?`)) {
                        game.souls -= c.cost; game.updateSoulsUI(); unlockedData.push(c.id); localStorage.setItem('unlockedChars', JSON.stringify(unlockedData)); location.reload();
                    }
                }
            }
        };
        select.appendChild(el);
    });

    // UI Lobby Multiplayer Selection
    const lobbySelect = document.getElementById('lobby-char-selection');
    chars.forEach((c, index) => {
        const isUnlocked = unlockedData.includes(c.id); 
        if(!isUnlocked) return; // SÃ³ mostra destrancados no lobby

        const el = document.createElement('div');
        el.className = `char-card`; if (index === 0) el.classList.add('selected');
        el.innerHTML = `<img src="Assets/mage${c.id}.png" style="width:64px;height:64px;display:block;margin:0 auto;object-fit:contain;" alt="Mage ${c.id}">
            <p>${c.name}</p>`;
            
        el.onclick = () => {
            audioManager.playWav('botton'); 
            document.querySelectorAll('#lobby-char-selection .char-card').forEach(x => x.classList.remove('selected')); el.classList.add('selected'); 
            Net.setChar(c.id);
        };
        lobbySelect.appendChild(el);
    });


    window.selectedChar = 1; requestAnimationFrame(() => game.loop());
}

window.onload = initGame;
</script>
</body>
</html>

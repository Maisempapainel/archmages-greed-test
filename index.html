<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Archmage's Greed</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            margin: 0;
            background-color: #111;
            color: white;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #050505;
        }

        canvas {
            background-color: #000;
            border: 2px solid #333;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.05);
        }

        /* UI Elements */
        .ui-layer {
            position: absolute;
            pointer-events: none;
            width: 1472px; 
            height: 690px;
        }

        #hud-top-left {
            position: absolute;
            top: 20px;
            left: 20px;
            text-align: left;
            display: none; 
        }

        #hud-top-right {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
            color: #4da6ff; 
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 10px;
            pointer-events: auto;
        }

        #souls-container { opacity: 1 !important; }

        #wave-display {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 40px;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            color: white;
            text-shadow: 0 0 10px white;
            pointer-events: none;
        }

        /* Menus */
        .menu-screen {
            position: absolute;
            width: 1472px;
            height: 690px;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 100;
        }

        .hidden { display: none !important; }

        h1 { margin-bottom: 30px; text-transform: uppercase; font-size: 30px; text-align: center; }
        
        .btn {
            background: transparent;
            border: 2px solid white;
            color: white;
            padding: 15px 30px;
            font-family: inherit;
            font-size: 16px;
            cursor: pointer;
            margin: 10px;
            transition: 0.2s;
        }
        .btn:hover { background: white; color: black; }
        .btn:disabled { opacity: 0.3; cursor: not-allowed; }

        /* Character Select */
        .char-select-container { display: flex; gap: 20px; margin-bottom: 20px; }
        .char-card {
            border: 1px solid #555; padding: 10px; cursor: pointer; text-align: center; width: 120px;
        }
        .char-card.selected { border: 2px solid white; background: #222; }
        .char-locked { opacity: 0.5; filter: grayscale(100%); }

        /* Upgrade Screen */
        #upgrade-container { display: flex; flex-direction: row; flex-wrap: wrap; justify-content: center; gap: 15px; max-width: 1100px; }
        .upgrade-card {
            border: 2px solid white; width: 180px; min-height: 220px; padding: 15px; text-align: center; cursor: pointer;
            transition: opacity 0.5s, transform 0.2s; position: relative; display: flex; flex-direction: column;
            align-items: center; justify-content: flex-start; background: #000;
        }
        .upgrade-card:hover { transform: scale(1.05); z-index: 50; }
        .rarity-common { border-color: #fff; color: #fff; }
        .rarity-uncommon { border-color: #4dff4d; color: #4dff4d; }
        .rarity-epic { border-color: #bf00ff; color: #bf00ff; }
        .rarity-legendary { border-color: #ffd700; color: #ffd700; box-shadow: 0 0 15px #ffd700; }
        
        .card-locked { opacity: 0.6; pointer-events: none; }
        .card-unlocked { opacity: 1; pointer-events: auto; }
        .card-desc { font-size: 10px; margin-top: 10px; line-height: 1.4; color: #ccc; word-wrap: break-word; }
        .card-title { font-size: 14px; margin: 10px 0; min-height: 30px; display:flex; align-items:center; justify-content:center; line-height: 1.3;}
        .card-tier { font-size: 10px; font-weight: bold; margin-bottom: 5px; display: block; }

        /* Bars */
        .bar-container { width: 200px; height: 10px; background: #333; margin-bottom: 5px; border: 1px solid white; }
        .bar-fill { height: 100%; transition: width 0.2s; }
        #hp-bar { background: white; }
        
        #audio-hint {
            position: absolute; bottom: 50px; width: 100%; text-align: center; font-size: 10px; color: #666; animation: pulse 2s infinite;
        }
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 1; } 100% { opacity: 0.5; } }

        /* Audio Controls */
        #audio-controls {
            position: absolute; bottom: 20px; right: 20px; z-index: 1000; display: flex; align-items: center; gap: 10px; background: rgba(0,0,0,0.5); padding: 5px; border-radius: 5px;
        }
        input[type=range] { width: 80px; cursor: pointer; }

        /* Buttons */
        #pause-btn-ingame, #perk-list-btn, #stats-btn {
            cursor: pointer; border: 1px solid white; padding: 5px 10px; font-size: 12px; background: #222; color: white; font-family: inherit; display: none; 
        }
        #pause-btn-ingame:hover, #perk-list-btn:hover, #stats-btn:hover { background: #444; border-color: white; }
        #perk-list-btn { position: absolute; left: 20px; bottom: 20px; z-index: 900; pointer-events: auto; padding: 10px 15px; }
        #stats-btn { position: absolute; left: 120px; bottom: 20px; z-index: 900; pointer-events: auto; padding: 10px 15px; }

        #perk-modal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 600px; height: 400px; background: rgba(10, 10, 10, 0.98); border: 2px solid white; z-index: 2000; padding: 20px; display: flex; flex-direction: column; overflow: hidden;
        }
        #perk-list-content { flex: 1; overflow-y: auto; margin-top: 10px; font-size: 10px; line-height: 1.8; }
        .perk-entry { border-bottom: 1px solid #333; padding: 8px 5px; display: flex; flex-direction: column; cursor: pointer; transition: 0.2s; }
        .perk-entry:hover { background: rgba(255,255,255,0.05); }
        .perk-entry .header { display: flex; justify-content: space-between; pointer-events: none;}
        .perk-entry .header span:last-child { color: #4da6ff; }
        .perk-desc { color: #aaa; font-size: 8px; margin-top: 5px; white-space: normal; line-height: 1.4; pointer-events: none; }

        #timer-bar-container { width: 100%; max-width: 800px; height: 5px; background: #333; margin-top: 20px; }
        #timer-bar { height: 100%; background: white; width: 100%; transition: width 1s linear; }

        /* Stats Panel */
        #stats-panel {
            position: absolute; top: 80px; left: 20px; background: rgba(0,0,0,0.8); border: 2px solid #555; padding: 15px; font-size: 10px; line-height: 2.0; pointer-events: none; border-radius: 5px; min-width: 200px; z-index: 10;
        }
        #stats-panel div { display: flex; justify-content: space-between; }

        /* Language Flags */
        .lang-select { display: flex; gap: 15px; margin-bottom: 20px; }
        .flag-btn { font-size: 16px; cursor: pointer; opacity: 0.5; transition: 0.2s; background: #222; border: 2px solid #555; color: white; padding: 10px 15px; font-family: inherit; }
        .flag-btn.active { opacity: 1; transform: scale(1.1); border-color: white;}
        .flag-btn:hover { opacity: 0.8; }
        
        /* Laser UI & Teleport UI */
        #laser-ui {
            display: none; position: absolute; top: 20px; left: 240px; width: 45px; height: 45px; border: 2px solid red; background: rgba(255,0,0,0.2); cursor: pointer; align-items: center; justify-content: center; flex-direction: column; border-radius: 5px; pointer-events: auto; z-index: 100;
        }
        #teleport-ui {
            display: none; position: absolute; top: 20px; left: 295px; width: 45px; height: 45px; border: 2px solid cyan; background: rgba(0,255,255,0.2); cursor: pointer; align-items: center; justify-content: center; flex-direction: column; border-radius: 5px; pointer-events: auto; z-index: 100;
        }
        #teleport-fade {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: white; opacity: 0; pointer-events: none; transition: opacity 0.7s ease; z-index: 9999; display: none;
        }

        /* Dev Console */
        #dev-console {
            position: absolute; bottom: 60px; left: 20px; z-index: 9999; background: rgba(0,0,0,0.85); padding: 10px; border: 2px solid #555; pointer-events: auto; border-radius: 5px;
        }
        #dev-input {
            background: #000; color: #0f0; border: none; font-family: inherit; font-size: 10px; width: 300px; outline: none; padding: 5px;
        }
        
        /* Multiplayer Menu UI */
        #multiplayer-menu {
            margin-top: 20px; text-align: center; border: 1px solid #555; padding: 15px; background: #111; width: 400px;
        }
    </style>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
</head>
<body>

<div id="game-container">
    <div id="fade-overlay" style="position:absolute; top:0; left:0; width:100%; height:100%; background:black; opacity:0; pointer-events:none; z-index:9999;"></div>
    <div id="teleport-fade"></div>

    <canvas id="gameCanvas" width="1472" height="690"></canvas>

    <div class="ui-layer">
        <div id="hud-top-left">
            <div>HP <span id="hp-text">100/100</span></div>
            <div class="bar-container"><div id="hp-bar" class="bar-fill" style="width: 100%;"></div></div>
            <div id="mana-shield-indicator" style="display:none; font-size:10px; color:#4dff4d; margin-top:5px;">[SHIELD]</div>
            <div id="phoenix-indicator" style="display:none; font-size:10px; color:#ffd700; margin-top:5px;">[PHOENIX]</div>
        </div>
        
        <div id="laser-ui" onclick="if(game && game.player) game.player.activateLaser()">
            <span style="color:red; font-size:16px;">âš¡</span>
            <span id="laser-cd" style="font-size:8px; margin-top:2px;">PRONTO</span>
        </div>
        
        <div id="teleport-ui" onclick="if(game && game.player) game.player.activateTeleport()">
            <span style="color:cyan; font-size:16px;">ðŸŒ€</span>
            <span id="teleport-cd" style="font-size:8px; margin-top:2px;">PRONTO</span>
        </div>

        <div id="stats-panel" class="hidden">
            <h3 style="margin:0 0 10px 0; text-align:center; font-size:12px; color:#4da6ff;">STATUS</h3>
            <div>Vida MÃ¡x: <span id="stat-maxhp">100</span></div>
            <div>Dano Base: <span id="stat-dmg">10</span></div>
            <div>Vel. Ataque: <span id="stat-atkspd">1.00</span>/s</div>
            <div>Chance CrÃ­tico: <span id="stat-critc">5</span>%</div>
            <div>Dano CrÃ­tico: <span id="stat-critd">200</span>%</div>
            <div>Roubo de Vida: <span id="stat-lifesteal">0</span>%</div>
            <div style="font-size:8px;color:#aaa; justify-content:flex-end;">(MÃ¡x 2% HP)</div>
        </div>

        <div id="hud-top-right">
            <div id="souls-container">
                <span id="souls-label">Almas</span>: <span id="souls-text">0</span>
            </div>
            <button id="pause-btn-ingame" onclick="audioManager.playWav('botton'); game.togglePause()">PAUSE (ESC)</button>
        </div>
        <div id="wave-display">WAVE 1</div>
        
        <button id="perk-list-btn" onclick="audioManager.playWav('botton'); togglePerkModal()">PERKS</button>
        <button id="stats-btn" onclick="audioManager.playWav('botton'); document.getElementById('stats-panel').classList.toggle('hidden');">STATS</button>
    </div>

    <div id="dev-console" class="hidden">
        <input type="text" id="dev-input" placeholder="> Comando (/wave 15, /perk catalyst)" autocomplete="off" />
    </div>

    <div id="perk-modal" class="hidden">
        <h3 id="perk-modal-title" style="text-align:center; margin-top:0;">PERKS COLETADOS</h3>
        <p style="text-align:center; font-size:8px; color:#666; margin-bottom:10px;">(Clique em um perk para ver a descriÃ§Ã£o)</p>
        <div id="perk-list-content"></div>
        <button class="btn" onclick="audioManager.playWav('botton'); togglePerkModal()" style="margin-top:10px; padding: 5px 10px;" id="btn-close-perks">FECHAR</button>
    </div>

    <div id="audio-controls">
        <button id="mute-btn" class="btn" onclick="audioManager.playWav('botton'); audioManager.toggleMute()" style="padding: 5px; font-size: 10px; border:none; width: 30px;">ðŸ”Š</button>
        <input type="range" id="volume-slider" min="0" max="1" step="0.1" value="0.5" oninput="audioManager.setVolume(this.value)">
    </div>

    <div id="main-menu" class="menu-screen">
        <div class="lang-select">
            <button class="flag-btn active" id="lang-pt" onclick="audioManager.playWav('botton'); setLanguage('pt')">ðŸ‡§ðŸ‡· PT-BR</button>
            <button class="flag-btn" id="lang-en" onclick="audioManager.playWav('botton'); setLanguage('en')">ðŸ‡ºðŸ‡¸ EN-US</button>
        </div>
        <h1>Archmage's Greed</h1>
        <div class="char-select-container" id="char-selection"></div>
        
        <div id="multiplayer-menu">
            <h3 style="margin-top:0; font-size:12px; color:#4da6ff;">MULTIPLAYER (P2P)</h3>
            <p style="font-size:10px;">O meu ID (Host): <span id="my-id" style="color:yellow;">A gerar...</span></p>
            <div style="margin-top: 15px;">
                <input type="text" id="friend-id" placeholder="ID do Amigo" style="padding: 8px; font-family: inherit; font-size: 10px; width: 220px; background: #000; color: #fff; border: 1px solid #555;">
                <button class="btn" onclick="audioManager.playWav('botton'); joinGame()" style="padding: 8px 15px; font-size: 10px;">ENTRAR (Guest)</button>
            </div>
            <p id="multiplayer-status" style="font-size:10px; color:#00ff00; margin-top:10px;"></p>
        </div>

        <button class="btn" id="btn-play" onclick="audioManager.playWav('botton'); startGameSingle()">JOGAR SOLO</button>
        <p id="controls-hint" style="font-size: 10px; color: #888;">Use A/D para Mover, EspaÃ§o p/ Pular, Mouse p/ Mirar, F p/ Habilidade</p>
        <div id="audio-hint">Clique para ativar o som</div>
    </div>

    <div id="upgrade-menu" class="menu-screen hidden">
        <h2 id="wave-complete-text">WAVE COMPLETE!</h2>
        <p id="choose-perk-text" style="font-size:12px; margin-bottom:10px; color:#ccc">Escolha um perk para avanÃ§ar</p>
        <div id="upgrade-container"></div>
        <div id="timer-bar-container"><div id="timer-bar"></div></div>
        <p id="timer-text" style="font-size:10px; margin-top:5px;">20s</p>
    </div>
    
    <div id="boss-confirm-menu" class="menu-screen hidden">
        <h1 id="boss-wave-title" style="color:#bf00ff">BOSS WAVE</h1>
        <p id="boss-warning-text" style="margin-bottom: 20px;">VocÃª estÃ¡ pronto?</p>
        <button class="btn" id="btn-start-boss" onclick="audioManager.playWav('botton'); confirmBossWave()">COMEÃ‡AR</button>
    </div>

    <div id="pause-menu" class="menu-screen hidden" style="background: rgba(0,0,0,0.8);">
        <h1 id="pause-title">PAUSADO</h1>
        <button class="btn" id="btn-resume" onclick="audioManager.playWav('botton'); game.togglePause()">CONTINUAR</button>
        <button class="btn" id="btn-giveup" onclick="audioManager.playWav('botton'); returnToMenu()" style="border-color: red; color: red;">DESISTIR</button>
    </div>

    <div id="game-over-menu" class="menu-screen hidden">
        <h1 id="game-over-title" style="color:red">VOCÃŠ MORREU</h1>
        <p><span id="stats-wave">Ondas</span>: <span id="final-wave">0</span></p>
        <p><span id="stats-souls">Almas</span>: <span id="final-souls">0</span></p>
        <button class="btn" id="btn-menu" onclick="audioManager.playWav('botton'); returnToMenu()">MENU</button>
    </div>
</div>

<script>
/**
 * LÃ“GICA DE MULTIPLAYER P2P (PEERJS)
 */
let peer = null;
let conn = null;
let isHost = true;
let isMultiplayer = false;

function initMultiplayer() {
    peer = new Peer(); 
    
    peer.on('open', (id) => {
        document.getElementById('my-id').innerText = id;
    });

    // Se alguÃ©m se conectar a nÃ³s (NÃ³s somos o Host)
    peer.on('connection', (connection) => {
        conn = connection;
        isHost = true;
        isMultiplayer = true;
        document.getElementById('multiplayer-status').innerText = "Amigo conectando...";
        document.getElementById('multiplayer-status').style.color = "yellow";
        setupConnection();
    });

    peer.on('error', (err) => {
        document.getElementById('multiplayer-status').innerText = "Erro P2P: " + err.type;
        document.getElementById('multiplayer-status').style.color = "red";
    });
}

function joinGame() {
    // O .trim() previne que espaÃ§os em branco acidentais quebrem a conexÃ£o
    const friendId = document.getElementById('friend-id').value.trim();
    if(!friendId) return;
    
    conn = peer.connect(friendId);
    isHost = false;
    isMultiplayer = true;
    document.getElementById('multiplayer-status').innerText = "A conectar...";
    document.getElementById('multiplayer-status').style.color = "yellow";
    setupConnection();
}

function setupConnection() {
    conn.on('open', () => {
        console.log("Conectado P2P estabelecido!");
        
        if (isHost) {
            document.getElementById('multiplayer-status').innerText = "Conectado! ComeÃ§ando...";
            document.getElementById('multiplayer-status').style.color = "#00ff00";
            
            // Host dita as regras: Diz pro Guest comeÃ§ar, e depois ele mesmo comeÃ§a
            setTimeout(() => {
                conn.send({ type: 'start_game' });
                startGameSingle();
            }, 1000);
        } else {
            document.getElementById('multiplayer-status').innerText = "Conectado! Aguardando Host...";
            document.getElementById('multiplayer-status').style.color = "#00ff00";
        }
    });

    conn.on('data', (data) => {
        if (!game) return;

        // O Guest sÃ³ comeÃ§a o jogo quando o Host mandar (Garante que os dois comeÃ§am juntos)
        if (data.type === 'start_game' && !isHost) {
            document.getElementById('multiplayer-status').innerText = "Partida iniciada!";
            startGameSingle();
        }

        // Receber posiÃ§Ã£o do jogador parceiro
        if (data.type === 'player_update') {
            if(!game.remotePlayer) {
                game.remotePlayer = new Player(data.x, data.y, data.charIndex || 1);
            }
            game.remotePlayer.x = data.x;
            game.remotePlayer.y = data.y;
            game.remotePlayer.facing = data.facing;
            game.remotePlayer.hp = data.hp;
            game.remotePlayer.maxHp = data.maxHp;
        }

        // Receber disparos do parceiro
        if (data.type === 'shoot') {
            let b = ObjectPool.getBullet(data.x, data.y, data.angle, data.damage, true, data.stats);
            game.bullets.push(b);
        }

        // Guest recebe estado dos inimigos e da wave do Host
        if (!isHost && data.type === 'host_state') {
            // SÃ³ sincroniza os inimigos se o Guest jÃ¡ estiver com o jogo rodando na tela
            if (game.state === 'PLAYING') {
                game.wave = data.wave;
                syncEnemies(data.enemies);
            }
        }
    });
}

// O Guest apenas renderiza os inimigos onde o Host mandou
function syncEnemies(remoteEnemies) {
    // 1. Limpa os inimigos da tela do Guest devolvendo-os para a Pool corretamente
    game.enemies.forEach(e => {
        if (e.type !== 'boss' && e.type !== 'miniboss') ObjectPool.releaseEnemy(e);
    });
    
    // 2. Posiciona os inimigos exatamente como o Host ordenou
    game.enemies = remoteEnemies.map(re => {
        let e = ObjectPool.getEnemy(re.x, re.y, re.eType);
        e.hp = re.hp;
        e.maxHp = re.maxHp;
        e.dead = re.dead;
        e.width = re.width;
        e.height = re.height;
        e.shieldActive = re.shieldActive;
        e.poisonActive = re.poisonActive;
        e.type = re.eType; 
        return e;
    });
}


/**
 * GLOBAL TIME SCALE & HELPERS
 */
window.timeScale = 1.0;

function distToSegmentSquared(p, v, w) {
    let l2 = (w.x - v.x)**2 + (w.y - v.y)**2;
    if (l2 === 0) return (p.x - v.x)**2 + (p.y - v.y)**2;
    let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    t = Math.max(0, Math.min(1, t));
    return (p.x - (v.x + t * (w.x - v.x)))**2 + (p.y - (v.y + t * (w.y - v.y)))**2;
}
function distToSegment(p, v, w) { return Math.sqrt(distToSegmentSquared(p, v, w)); }

// FunÃ§Ã£o para Escalonamento de Dano DinÃ¢mico dos Inimigos
function getEnemyBaseDamage(wave) {
    if (wave < 15) return 5 + (wave * (5/15)); // ComeÃ§a em 5, vai pra 10 na wave 15
    if (wave <= 20) return 10 + ((wave - 15) * (4/5)); // Vai pra 14 na wave 20
    if (wave <= 25) return 14 + ((wave - 20) * (6/5)); // Vai pra ~20 na wave 25
    return 20 + ((wave - 25) * 2.5); // Escala mais rÃ¡pido apÃ³s a wave 25
}

/**
 * LOCALIZAÃ‡ÃƒO
 */
let currentLang = 'pt';
const TEXTS = {
    pt: {
        play: "JOGAR SOLO", controls: "Use A/D p/ Mover, EspaÃ§o p/ Pular, Mouse p/ Mirar, F p/ Habilidade", waveComplete: "ONDA CONCLUÃDA!", choosePerk: "Escolha um perk para avanÃ§ar",
        bossWave: "CHEFE", miniBoss: "MINI CHEFE", ready: "VocÃª estÃ¡ pronto?", start: "COMEÃ‡AR", paused: "PAUSADO", resume: "CONTINUAR", giveUp: "DESISTIR",
        gameOver: "VOCÃŠ MORREU", waves: "Ondas", souls: "Almas", menu: "MENU", perksTitle: "PERKS COLETADOS", close: "FECHAR", blocked: "BLOQUEADO",
        revived: "RENASCEU!", perks: "PERKS", shield: "[ESCUDO]", phoenix: "[FENIX]", acquired: "Adquirido", tier: "NÃ­vel"
    },
    en: {
        play: "PLAY SOLO", controls: "Use A/D to Move, Space to Jump, Mouse to Aim, F for Skill", waveComplete: "WAVE COMPLETE!", choosePerk: "Choose a perk to advance",
        bossWave: "BOSS WAVE", miniBoss: "MINI BOSS", ready: "Are you sure?", start: "START", paused: "PAUSED", resume: "RESUME", giveUp: "GIVE UP",
        gameOver: "YOU DIED", waves: "Waves Survived", souls: "Souls Earned", menu: "MAIN MENU", perksTitle: "COLLECTED PERKS", close: "CLOSE", blocked: "BLOCKED",
        revived: "REVIVED!", perks: "PERKS", shield: "[SHIELD]", phoenix: "[PHOENIX]", acquired: "Acquired", tier: "Tier"
    }
};

function setLanguage(lang) {
    currentLang = lang;
    document.getElementById('lang-pt').classList.toggle('active', lang === 'pt');
    document.getElementById('lang-en').classList.toggle('active', lang === 'en');
    
    const t = TEXTS[lang];
    document.getElementById('btn-play').innerText = t.play;
    document.getElementById('controls-hint').innerText = t.controls;
    document.getElementById('wave-complete-text').innerText = t.waveComplete;
    document.getElementById('choose-perk-text').innerText = t.choosePerk;
    document.getElementById('boss-warning-text').innerText = t.ready;
    document.getElementById('btn-start-boss').innerText = t.start;
    document.getElementById('pause-title').innerText = t.paused;
    document.getElementById('btn-resume').innerText = t.resume;
    document.getElementById('btn-giveup').innerText = t.giveUp;
    document.getElementById('game-over-title').innerText = t.gameOver;
    document.getElementById('stats-wave').innerText = t.waves;
    document.getElementById('stats-souls').innerText = t.souls;
    document.getElementById('btn-menu').innerText = t.menu;
    document.getElementById('perk-modal-title').innerText = t.perksTitle;
    document.getElementById('btn-close-perks').innerText = t.close;
    document.getElementById('perk-list-btn').innerText = t.perks;
    document.getElementById('mana-shield-indicator').innerText = t.shield;
    document.getElementById('phoenix-indicator').innerText = t.phoenix;
    document.getElementById('souls-label').innerText = t.souls;
}

/**
 * CONFIGURAÃ‡Ã•ES GERAIS
 */
const CONFIG = {
    gravity: 0.28, friction: 0.8, playerSpeed: 1.5, jumpForce: 8.8, 
    baseEnemyHP: 20, bossWaveInterval: 10, miniBossInterval: 5,
    colors: { bg: '#000', player: '#fff', enemy: '#ccc', boss: '#eee', bullet: '#fff' }
};

/**
 * CACHE SYSTEM PARA PERFORMANCE
 */
const ObjectPool = {
    bullets: [], enemies: [], particles: [],

    getBullet(x, y, angle, damage, isPlayer, stats) {
        if (this.bullets.length > 0) { let b = this.bullets.pop(); b.reset(x, y, angle, damage, isPlayer, stats); return b; }
        return new Projectile(x, y, angle, damage, isPlayer, stats);
    },
    releaseBullet(b) { this.bullets.push(b); },

    getEnemy(x, y, type) {
        if (this.enemies.length > 0) { let e = this.enemies.pop(); e.reset(x, y, type); return e; }
        return new Enemy(x, y, type);
    },
    releaseEnemy(e) { this.enemies.push(e); },

    getParticle(x, y, color, size, duration, speedMult = 1) {
        if (this.particles.length > 0) { let p = this.particles.pop(); p.reset(x, y, color, size, duration, speedMult); return p; }
        return new Particle(x, y, color, size, duration, speedMult);
    },
    releaseParticle(p) { this.particles.push(p); }
};

/**
 * ASSETS E ÃUDIO
 */
const ASSETS = { 
    images: { 
        mage1: new Image(), mage2: new Image(), mage3: new Image(),
        triangulo: new Image(), losango: new Image(), redondo: new Image(),
        miniboss: new Image(), boss: new Image()
    }, 
    audio: { main: new Audio(), principal: new Audio(), boss: new Audio(), botton: new Audio(), bossdefeat: new Audio() } 
};
ASSETS.images.mage1.src = 'Assets/mage1.png'; ASSETS.images.mage2.src = 'Assets/mage2.png'; ASSETS.images.mage3.src = 'Assets/mage3.png';
ASSETS.images.triangulo.src = 'Assets/triangulo.png'; ASSETS.images.losango.src = 'Assets/losango.png'; ASSETS.images.redondo.src = 'Assets/redondo.png';
ASSETS.images.miniboss.src = 'Assets/miniboss.png'; ASSETS.images.boss.src = 'Assets/boss.png';

ASSETS.audio.main.src = 'Assets/Main.wav'; ASSETS.audio.main.loop = true;
ASSETS.audio.principal.src = 'Assets/Principal.wav'; ASSETS.audio.principal.loop = true;
ASSETS.audio.boss.src = 'Assets/Boss.wav'; ASSETS.audio.boss.loop = true;
ASSETS.audio.botton.src = 'Assets/botton.wav';
ASSETS.audio.bossdefeat.src = 'Assets/bossdefeat.wav';

const audioManager = {
    current: null, context: null, isMuted: false, 
    globalVolume: parseFloat(localStorage.getItem('gameVolume') !== null ? localStorage.getItem('gameVolume') : 0.5),
    
    init() {
        if (!this.context) this.context = new (window.AudioContext || window.webkitAudioContext)();
        if (this.context.state === 'suspended') this.context.resume();
    },
    setVolume(val) {
        this.globalVolume = parseFloat(val);
        localStorage.setItem('gameVolume', this.globalVolume);
        if (this.current) this.current.volume = this.globalVolume;
    },
    toggleMute() {
        this.isMuted = !this.isMuted;
        document.getElementById('mute-btn').innerText = this.isMuted ? 'ðŸ”‡' : 'ðŸ”Š';
        ASSETS.audio.main.muted = this.isMuted; ASSETS.audio.principal.muted = this.isMuted; ASSETS.audio.boss.muted = this.isMuted;
    },
    play(trackName) {
        this.init();
        if (this.current === ASSETS.audio[trackName] && !this.current.paused) return;
        if (this.current) { this.current.pause(); this.current.currentTime = 0; }
        if (ASSETS.audio[trackName]) {
            this.current = ASSETS.audio[trackName];
            this.current.volume = this.globalVolume;
            this.current.play().catch(e => console.log("Aguardando interaÃ§Ã£o..."));
        }
    },
    playWav(trackName) {
        if (this.isMuted) return;
        this.init();
        if (ASSETS.audio[trackName]) {
            const snd = ASSETS.audio[trackName].cloneNode();
            snd.volume = this.globalVolume;
            snd.play().catch(e => {});
        }
    },
    playSfx(type) {
        if (this.isMuted) return;
        this.init();
        const ctx = this.context; const osc = ctx.createOscillator(); const gain = ctx.createGain();
        osc.connect(gain); gain.connect(ctx.destination);
        const now = ctx.currentTime; const vol = this.globalVolume; 
        
        if (type === 'shoot') {
            osc.type = 'square'; osc.frequency.setValueAtTime(300 + Math.random() * 100, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
            gain.gain.setValueAtTime(0.03 * vol, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1); osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'hit') {
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(150, now); gain.gain.setValueAtTime(0.05 * vol, now); gain.gain.linearRampToValueAtTime(0, now + 0.1); osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'shatter') { 
            osc.type = 'triangle'; osc.frequency.setValueAtTime(800, now); osc.frequency.linearRampToValueAtTime(100, now + 0.05);
            gain.gain.setValueAtTime(0.02 * vol, now); gain.gain.linearRampToValueAtTime(0, now + 0.05); osc.start(now); osc.stop(now + 0.05);
        } else if (type === 'select') {
            osc.type = 'sine'; osc.frequency.setValueAtTime(600 + Math.random() * 300, now); gain.gain.setValueAtTime(0.05 * vol, now); gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1); osc.start(now); osc.stop(now + 0.1);
        } else if (type === 'thunder') {
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(50, now); osc.frequency.linearRampToValueAtTime(20, now + 0.3);
            gain.gain.setValueAtTime(0.2 * vol, now); gain.gain.linearRampToValueAtTime(0, now + 0.3); osc.start(now); osc.stop(now + 0.3);
        } else if (type === 'boss_die') {
            osc.type = 'square'; osc.frequency.setValueAtTime(100, now); osc.frequency.linearRampToValueAtTime(10, now + 1.0);
            gain.gain.setValueAtTime(0.3 * vol, now); gain.gain.linearRampToValueAtTime(0, now + 1.0); osc.start(now); osc.stop(now + 1.0);
        } else if (type === 'phoenix') {
            osc.type = 'triangle'; osc.frequency.setValueAtTime(200, now); osc.frequency.linearRampToValueAtTime(800, now + 0.5);
            gain.gain.setValueAtTime(0.2 * vol, now); gain.gain.linearRampToValueAtTime(0, now + 0.5); osc.start(now); osc.stop(now + 0.5);
        } else if (type === 'laser') {
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.linearRampToValueAtTime(80, now + 0.2);
            gain.gain.setValueAtTime(0.04 * vol, now); gain.gain.linearRampToValueAtTime(0.01, now + 0.2); osc.start(now); osc.stop(now + 0.2);
        } else if (type === 'teleport') {
            osc.type = 'sine'; osc.frequency.setValueAtTime(100, now); osc.frequency.exponentialRampToValueAtTime(800, now + 1.0);
            gain.gain.setValueAtTime(0.15 * vol, now); gain.gain.linearRampToValueAtTime(0, now + 1.0); osc.start(now); osc.stop(now + 1.0);
        }
    }
};

/**
 * UPGRADES DATA 
 */
const maxTierCheck = (p, id, max) => (p.perksCounts[id] || 0) >= max;

const UPGRADES_DB = {
    common: [
        { id: 'pursuing_orb', name_en: 'Pursuing Orb', name_pt: 'Orbe Perseguidora', max: 3, desc_en: 'Orb automatically shoots enemies.', desc_pt: 'Orbe que atira nos inimigos automaticamente.', apply: (p) => p.perks.pursuingOrb++ },
        { id: 'catalyst', name_en: 'Catalyst', name_pt: 'Catalisador', max: 99, desc_en: 'Damage +20%.', desc_pt: 'Dano +20%.', apply: (p) => p.stats.damage *= 1.2 },
        { id: 'eyesight', name_en: 'Eyesight', name_pt: 'VisÃ£o AguÃ§ada', max: 5, desc_en: 'Crit Chance +5%.', desc_pt: 'Chance CrÃ­tica +5%.', apply: (p) => p.stats.critChance += 0.05 },
        { id: 'growth', name_en: 'Growth', name_pt: 'Crescimento', max: 99, desc_en: 'Max HP +10.', desc_pt: 'Vida MÃ¡xima +10.', apply: (p) => { p.maxHp += 10; p.hp += 10; p.updateHpUI(); } },
        { id: 'impulse', name_en: 'Impulse', name_pt: 'Impulso', max: 99, desc_en: 'Jump Height +30%.', desc_pt: 'Altura do Pulo +30%.', apply: (p) => p.stats.jumpPower *= 1.3 },
        { id: 'renew', name_en: 'Renew', name_pt: 'Renovar', max: 99, desc_en: 'Full Heal.', desc_pt: 'Cura vida completamente.', apply: (p) => { p.hp = p.maxHp; p.updateHpUI(); } },
        { id: 'resist', name_en: 'Resist', name_pt: 'ResistÃªncia', max: 99, desc_en: 'Defense +4%.', desc_pt: 'Defesa +4%.', apply: (p) => p.stats.defense += 0.04 },
        { id: 'resonance', name_en: 'Resonance', name_pt: 'RessonÃ¢ncia', max: 3, desc_en: 'Atk Speed +12%.', desc_pt: 'Velocidade de Ataque +12%.', apply: (p) => p.stats.fireRate *= 0.88 },
        { id: 'souls', name_en: 'Souls', name_pt: 'Almas', max: 99, desc_en: 'Soul drop +1%.', desc_pt: 'Chance de Almas +1%.', apply: (p) => p.stats.soulChance += 0.01 },
        { id: 'stability', name_en: 'Ricochet', name_pt: 'Ricochete', max: 3, desc_en: '30%/50%/100% chance to bounce to nearby enemy.', desc_pt: '30%/50%/100% chance de ricochetear p/ outro inimigo.', apply: (p) => p.perks.chainLightning++ },
        { id: 'swift', name_en: 'Swift', name_pt: 'Veloz', max: 3, desc_en: 'Move Speed +10% (Stacks 3x).', desc_pt: 'Velocidade de Movimento +10% (Acumula 3x).', apply: (p) => p.perks.swift++ },
        { id: 'leech', name_en: 'Leech', name_pt: 'Sanguessuga', max: 1, desc_en: 'Heal 5% of kill dmg (Max 2% HP)', desc_pt: 'Cura 5% do dano ao matar (Max 2% HP)', apply: (p) => p.stats.lifesteal = 0.05 }
    ],
    uncommon: [
        { id: 'catalyst_plus', name_en: 'Catalyst+', name_pt: 'Catalisador+', max: 99, desc_en: 'Damage +40%.', desc_pt: 'Dano +40%.', apply: (p) => p.stats.damage *= 1.4 },
        { id: 'charge', name_en: 'Charge', name_pt: 'Carga', max: 99, desc_en: 'Projectile Size +20%.', desc_pt: 'Tamanho do ProjÃ©til +20%.', apply: (p) => p.stats.projSize *= 1.2 },
        { id: 'fragmentation', name_en: 'Fragmentation', name_pt: 'FragmentaÃ§Ã£o', max: 1, desc_en: 'Enemies explode into fragments.', desc_pt: 'Inimigos explodem em fragmentos.', apply: (p) => p.perks.fragmentation = true },
        { id: 'gush', name_en: 'Gush', name_pt: 'Jato', max: 99, desc_en: '+1 Double Jump.', desc_pt: '+1 Pulo Duplo.', apply: (p) => p.stats.jumpsMax += 1 },
        { id: 'luck', name_en: 'Luck', name_pt: 'Sorte', max: 99, desc_en: 'Better RNG.', desc_pt: 'Melhor RNG (Sorte).', apply: (p) => game.luck += 0.2 },
        { id: 'precision', name_en: 'Precision', name_pt: 'PrecisÃ£o', max: 2, desc_en: 'Crit Dmg +20%.', desc_pt: 'Dano CrÃ­tico +20%.', apply: (p) => p.stats.critDmg += 0.2 },
        { id: 'resonance_plus', name_en: 'Resonance+', name_pt: 'RessonÃ¢ncia+', max: 3, desc_en: 'Atk Speed +24%.', desc_pt: 'Velocidade de Ataque +24%.', apply: (p) => p.stats.fireRate *= 0.76 },
        { id: 'shrink', name_en: 'Shrink', name_pt: 'Encolher', max: 99, desc_en: 'Player Size -10%.', desc_pt: 'Tamanho do Mago -10%.', apply: (p) => { p.width *= 0.9; p.height *= 0.9; } },
        { id: 'swift_plus', name_en: 'Swift+', name_pt: 'Veloz+', max: 99, desc_en: 'Move Speed +40% (Rare).', desc_pt: 'Velocidade de Movimento +40% (Raro).', apply: (p) => p.stats.speed *= 1.4 },
        { id: 'thunderbolt', name_en: 'Lightning Bolt', name_pt: 'Raio', max: 3, desc_en: 'Lightning strikes periodic enemies.', desc_pt: 'Raios atingem inimigos periodicamente.', apply: (p) => p.perks.thunderbolt++ },
        { id: 'homing', name_en: 'Homing Missiles', name_pt: 'MÃ­sseis Teleguiados', max: 3, desc_en: 'Shots seek frontal targets.', desc_pt: 'Tiros travam em inimigos Ã  frente.', apply: (p) => p.perks.homing++ },
        { id: 'timewarp', name_en: 'Time Warp', name_pt: 'Dobra Temporal', max: 3, desc_en: 'Enemies slow 10%/15%/20%.', desc_pt: 'Inimigos lentos 10%/15%/20%.', apply: (p) => p.perks.timeWarp++ },
        { id: 'multishot', name_en: 'Multishot', name_pt: 'Tiro MÃºltiplo', max: 1, desc_en: '20% chance extra shot.', desc_pt: '20% chance de tiro extra.', apply: (p) => p.perks.multishot = true },
        { id: 'cold', name_en: 'Cold', name_pt: 'Gelo', max: 1, desc_en: 'Slows enemy fire rate (Stacks).', desc_pt: 'LentidÃ£o no tiro inimigo (Acumula).', apply: (p) => p.perks.cold = true },
        { id: 'execute', name_en: 'Execute', name_pt: 'Executar', max: 1, desc_en: '2x Dmg if enemy < 15% HP.', desc_pt: '2x Dano se inimigo < 15% HP.', apply: (p) => p.perks.execute = true },
        { id: 'bouncing', name_en: 'Bouncing Bolt', name_pt: 'Parede ElÃ¡stica', max: 1, desc_en: 'Shots bounce off walls 1x.', desc_pt: 'Tiros quicam na parede 1x.', apply: (p) => p.perks.bouncing = true },
        { id: 'manashield', name_en: 'Mana Shield', name_pt: 'Escudo de Mana', max: 1, desc_en: 'Blocks 1 hit (20s cd).', desc_pt: 'Bloqueia 1 hit (20s recarga).', apply: (p) => { p.perks.manaShield = true; p.manaShieldReady = true; document.getElementById('mana-shield-indicator').style.display='block'; } },
        { id: 'leech_plus', name_en: 'Leech+', name_pt: 'Sanguessuga+', max: 1, desc_en: 'Heal 10% of kill dmg (Max 2% HP)', desc_pt: 'Cura 10% do dano ao matar (Max 2% HP)', apply: (p) => p.stats.lifesteal = 0.10 },
        { id: 'poison', name_en: 'Toxic Bloom', name_pt: 'Veneno', max: 3, desc_en: 'Chance to poison enemies (5s duration).', desc_pt: 'Chance de envenenar inimigos (5s de duraÃ§Ã£o).', apply: (p) => p.perks.poison++ }
    ],
    epic: [
        { id: 'growth_plus_plus', name_en: 'Growth++', name_pt: 'Crescimento++', max: 99, desc_en: 'Max HP +40.', desc_pt: 'Vida MÃ¡xima +40.', apply: (p) => { p.maxHp += 40; p.hp += 40; p.updateHpUI(); } },
        { id: 'leech_plus_plus', name_en: 'Leech++', name_pt: 'Sanguessuga++', max: 1, desc_en: 'Heal 15% of kill dmg (Max 2% HP)', desc_pt: 'Cura 15% do dano ao matar (Max 2% HP)', apply: (p) => p.stats.lifesteal = 0.15 },
        { id: 'decimator', name_en: 'Decimator Laser', name_pt: 'Raio Dizimador', max: 3, desc_en: 'Fires a thick laser for 4s (180s CD).', desc_pt: 'Dispara um laser poderoso por 4s (180s CD).', apply: (p) => p.perks.decimator++ }
    ],
    legendary: [
         { id: 'phoenix', name_en: 'Phoenix Feather', name_pt: 'Pena de FÃªnix', max: 1, desc_en: 'Revive with 40% HP & nuke enemies.', desc_pt: 'Revive com 40% HP e frita inimigos.', apply: (p) => { p.perks.phoenix = true; document.getElementById('phoenix-indicator').style.display='block'; } },
         { id: 'teleport', name_en: 'Teleporter', name_pt: 'Teleporte', max: 1, desc_en: 'Teleport to opposite side (300s CD).', desc_pt: 'Teleporta ao lado oposto (300s recarga).', apply: (p) => { p.perks.teleport = true; document.getElementById('teleport-ui').style.display='flex'; } }
    ]
};

/**
 * GAME ENGINE
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let game; 

function togglePerkModal() {
    if (game && game.state === 'PLAYING') game.togglePause();
    const modal = document.getElementById('perk-modal');
    if (modal.classList.contains('hidden')) {
        updatePerkListUI();
        modal.classList.remove('hidden');
    } else {
        modal.classList.add('hidden');
    }
}

function updatePerkListUI() {
    const content = document.getElementById('perk-list-content');
    content.innerHTML = '';
    if (!game || !game.player) return;

    const counts = game.player.perksCounts;
    for (let [id, count] of Object.entries(counts)) {
        if (count === 0) continue;
        const allPerks = [...UPGRADES_DB.common, ...UPGRADES_DB.uncommon, ...UPGRADES_DB.epic, ...UPGRADES_DB.legendary];
        const perkObj = allPerks.find(p => p.id === id);
        let perkName = id;
        if (perkObj) perkName = (currentLang === 'pt') ? perkObj.name_pt : perkObj.name_en;

        const row = document.createElement('div');
        row.className = 'perk-entry';
        let valText = perkObj && perkObj.max > 3 ? `x${count}` : `${TEXTS[currentLang].tier} ${count}`;
        if (perkObj && perkObj.max === 1) valText = TEXTS[currentLang].acquired;
        
        let descText = (currentLang === 'pt') ? perkObj.desc_pt : perkObj.desc_en;

        row.innerHTML = `<div class="header"><span>${perkName}</span><span>${valText}</span></div>
                         <div class="perk-desc hidden">${descText}</div>`;
        
        row.onclick = () => {
            const desc = row.querySelector('.perk-desc');
            desc.classList.toggle('hidden');
            audioManager.playWav('botton');
        };
        content.appendChild(row);
    }
}

class Game {
    constructor() {
        this.state = 'MENU';
        this.width = canvas.width;
        this.height = canvas.height;
        this.wave = 1;
        this.souls = parseInt(localStorage.getItem('savedSouls') || 0);
        this.luck = 1.0;
        this.upgradeChoices = 5;
        this.paused = false;
        
        this.player = null;
        this.remotePlayer = null; // InstÃ¢ncia do jogador 2
        
        this.bullets = [];
        this.enemies = [];
        this.particles = [];
        this.lightningEffects = [];
        this.floatingTexts = []; 
        
        this.blocks = [
            { x: 0, y: 490, w: 100, h: 200 },     
            { x: 100, y: 570, w: 100, h: 120 },   
            { x: 200, y: 650, w: 1072, h: 40 },    
            { x: 1272, y: 570, w: 100, h: 120 },  
            { x: 1372, y: 490, w: 100, h: 200 }   
        ];

        this.enemiesToSpawn = 0;
        this.lastSpawnTime = Date.now();
        this.lastThunderTime = Date.now();
        this.lastNetworkSync = Date.now();
        
        this.waveClusterX = this.width / 2;
        this.menuTimer = null; 
        this.manaShieldPausedTime = 0; 
        this.input = { keys: {}, mouse: { x: 0, y: 0 } };
        
        this.cinematicBoss = null;
        this.cinematicStartTime = 0;
        this.cinematicExplosionDone = false;
        this.showTeleportZonesUntil = 0;

        this.initInput();
        this.updateSoulsUI();
    }

    initInput() {
        window.addEventListener('keydown', e => {
            if(document.activeElement === document.getElementById('dev-input')) {
                if(e.code === 'Enter') {
                    this.processDevCommand(document.getElementById('dev-input').value);
                    document.getElementById('dev-console').classList.add('hidden');
                    canvas.focus();
                }
                return;
            }

            if (e.code === 'Enter') {
                const devCon = document.getElementById('dev-console');
                const devIn = document.getElementById('dev-input');
                if (devCon.classList.contains('hidden')) {
                    devCon.classList.remove('hidden');
                    devIn.value = '';
                    devIn.focus();
                    this.input.keys = {}; 
                }
            }
            if (e.code === 'Escape') {
                audioManager.playWav('botton');
                this.togglePause();
            }
            if (e.code === 'KeyF' && this.state === 'PLAYING' && this.player) {
                this.player.activateLaser();
            }
            if (e.code === 'KeyT' && this.state === 'PLAYING' && this.player) {
                this.player.activateTeleport();
            }
            this.input.keys[e.code] = true;
        });
        window.addEventListener('keyup', e => this.input.keys[e.code] = false);
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            this.input.mouse.x = e.clientX - rect.left;
            this.input.mouse.y = e.clientY - rect.top;
        });
        
        const unlockAudio = () => {
            audioManager.init();
            if (this.state === 'MENU' || this.state === 'GAME_OVER') audioManager.play('main');
            document.getElementById('audio-hint').style.display = 'none';
            window.removeEventListener('click', unlockAudio);
        };
        window.addEventListener('click', unlockAudio);
    }

    processDevCommand(cmd) {
        if(!cmd || !cmd.startsWith('/')) return;
        const parts = cmd.trim().split(' ');
        
        if (parts[0] === '/wave' && parts[1]) {
            this.wave = parseInt(parts[1]);
            this.enemies.forEach(e => e.dead = true);
            this.enemiesToSpawn = 0;
            this.state = 'PLAYING';
            this.addFloatingText(this.width/2, this.height/2, `PULANDO PARA WAVE ${this.wave}`, "yellow");
            this.startWave();
        } else if (parts[0] === '/perk' && parts[1]) {
            const perkId = parts[1];
            const allPerks = [...UPGRADES_DB.common, ...UPGRADES_DB.uncommon, ...UPGRADES_DB.epic, ...UPGRADES_DB.legendary];
            
            if (perkId === 'all') {
                if (this.player) {
                    allPerks.forEach(pObj => {
                        let currentCount = this.player.perksCounts[pObj.id] || 0;
                        let missing = pObj.max - currentCount;
                        for(let i=0; i < missing; i++){
                            pObj.apply(this.player);
                            this.player.perksCounts[pObj.id] = (this.player.perksCounts[pObj.id] || 0) + 1;
                        }
                    });
                    this.player.updateStatsUI();
                    this.addFloatingText(this.player.x, this.player.y - 40, `+ALL PERKS MAXED`, "#4dff4d");
                }
            } else {
                const pObj = allPerks.find(p => p.id === perkId);
                if (pObj && this.player) {
                    pObj.apply(this.player);
                    this.player.perksCounts[pObj.id] = (this.player.perksCounts[pObj.id] || 0) + 1;
                    this.player.updateStatsUI();
                    this.addFloatingText(this.player.x, this.player.y - 40, `+${perkId}`, "#4dff4d");
                }
            }
        }
    }

    togglePause() {
        if (this.state !== 'PLAYING' && this.state !== 'PAUSED') return;

        if (this.state === 'PLAYING') {
            this.state = 'PAUSED';
            this.paused = true;
            document.getElementById('pause-menu').classList.remove('hidden');
            if (this.player && !this.player.manaShieldReady && this.player.perks.manaShield) {
                this.manaShieldPausedTime = this.player.manaShieldCooldown - Date.now();
            }
        } else {
            this.state = 'PLAYING';
            this.paused = false;
            document.getElementById('pause-menu').classList.add('hidden');
            if (this.player && !this.player.manaShieldReady && this.player.perks.manaShield) {
                this.player.manaShieldCooldown = Date.now() + this.manaShieldPausedTime;
            }
        }
    }

    start(charIndex) {
        this.state = 'PLAYING';
        this.paused = false;
        this.player = new Player(this.width / 2, this.height - 150, charIndex);
        this.remotePlayer = null; // Limpa player anterior se houver
        this.bullets = []; this.enemies = []; this.particles = []; this.lightningEffects = []; this.floatingTexts = [];
        this.wave = 1;
        document.getElementById('teleport-ui').style.display = 'none';
        
        // Se formos host, controlamos a wave. Se nÃ£o, apenas observamos o que chega da net.
        if(isHost) this.startWave();
    }

    startWave() {
        if(!isHost) return; // Apenas o Host inicia as waves

        const isBoss = (this.wave % CONFIG.bossWaveInterval === 0 || this.wave % CONFIG.miniBossInterval === 0);
        if (isBoss) {
            this.state = 'BOSS_CONFIRM';
            const title = (this.wave % CONFIG.bossWaveInterval === 0) ? TEXTS[currentLang].bossWave : TEXTS[currentLang].miniBoss;
            document.getElementById('boss-wave-title').innerText = title;
            document.getElementById('boss-wave-title').style.color = (this.wave % CONFIG.bossWaveInterval === 0) ? 'red' : '#bf00ff';
            document.getElementById('boss-confirm-menu').classList.remove('hidden');
        } else {
            let baseSpawns = 2 + (this.wave * 1);
            if (this.player && this.player.perks.thunderbolt === 3) {
                baseSpawns = Math.floor(baseSpawns * 1.3);
            }
            this.enemiesToSpawn = baseSpawns;
            
            this.lastSpawnTime = Date.now();
            this.waveClusterX = 200 + Math.random() * (this.width - 400);
            audioManager.play('principal');
            this.showWaveText(`WAVE ${this.wave}`);
        }
    }

    triggerConfirmedBossWave() {
        this.state = 'PLAYING';
        audioManager.play('boss');
        this.enemiesToSpawn = 0; 
        this.spawnBoss(this.wave % CONFIG.bossWaveInterval === 0);
        const title = (this.wave % CONFIG.bossWaveInterval === 0) ? TEXTS[currentLang].bossWave : TEXTS[currentLang].miniBoss;
        this.showWaveText(title);
    }
    
    startBossDeathCinematic(boss) {
        this.state = 'BOSS_DEATH_CINEMATIC';
        this.cinematicBoss = boss;
        this.cinematicStartTime = Date.now();
        this.cinematicExplosionDone = false;
        
        if (audioManager.current) audioManager.current.pause();
        audioManager.playWav('bossdefeat');
    }

    startTeleport(fromLeft) {
        this.state = 'TELEPORTING';
        let fadeElement = document.getElementById('teleport-fade');
        fadeElement.style.display = 'block';
        
        setTimeout(() => fadeElement.style.opacity = 1, 10);
        audioManager.playSfx('teleport');

        setTimeout(() => {
            this.player.x = fromLeft ? this.width - 150 : 100;
            this.player.y = 50;
            this.player.vy = 0;
            
            // Host move os Inimigos
            if(isHost) {
                this.enemies.forEach(e => {
                    let newX = fromLeft ? 50 + Math.random() * 150 : this.width - 200 - Math.random() * 150;
                    newX = Math.max(0, Math.min(this.width - e.width, newX));
                    e.x = newX;
                    if (e.anchorX !== undefined) e.anchorX = newX;
                });
            }

            fadeElement.style.opacity = 0;
            setTimeout(() => {
                fadeElement.style.display = 'none';
                this.state = 'PLAYING';
            }, 700);
        }, 700);
    }

    createExplosion(x, y, color, count, baseSize, baseSpeed, duration) {
        for(let i = 0; i < count; i++) {
            if (this.particles.length >= 2000) break; 
            let p = ObjectPool.getParticle(x, y, color, baseSize + Math.random() * (baseSize * 0.5), duration);
            let angle = Math.random() * Math.PI * 2;
            let speed = baseSpeed + Math.random() * (baseSpeed * 0.8);
            
            p.vx = Math.cos(angle) * speed;
            p.vy = Math.sin(angle) * speed;
            
            this.particles.push(p);
        }
    }

    triggerCinematicExplosions() {
        this.cinematicBoss.dead = true;
        
        this.createExplosion(
            this.cinematicBoss.x + this.cinematicBoss.width / 2, 
            this.cinematicBoss.y + this.cinematicBoss.height / 2, 
            '#bf00ff', 80, 12, 8, 2000
        );
        
        this.enemies.forEach(e => {
            if (e !== this.cinematicBoss && !e.dead) {
                e.dead = true;
                this.createExplosion(e.x + e.width / 2, e.y + e.height / 2, 'white', 12, 6, 5, 1500);
            }
        });

        if (!this.cinematicBoss.isBigBoss) this.souls += 10; else this.souls += 30;
        this.updateSoulsUI();
    }

    endCinematic() {
        this.state = 'UPGRADE_MENU';
        window.timeScale = 1.0;
        this.enemies = []; 
        document.getElementById('fade-overlay').style.opacity = 0;
        audioManager.play('principal');
        
        if (this.player && !this.player.manaShieldReady && this.player.perks.manaShield) {
            this.manaShieldPausedTime = this.player.manaShieldCooldown - Date.now();
        }
        this.showUpgradeMenu();
    }

    showWaveText(text) {
        const el = document.getElementById('wave-display');
        el.innerText = text; el.style.opacity = 1;
        setTimeout(() => { el.style.opacity = 0; }, 3000);
    }

    updateSoulsUI() {
        document.getElementById('souls-text').innerText = this.souls;
        document.getElementById('final-souls').innerText = this.souls;
        localStorage.setItem('savedSouls', this.souls);
    }

    clearAllBullets() {
        for (let i = this.bullets.length - 1; i >= 0; i--) {
            ObjectPool.releaseBullet(this.bullets[i]);
        }
        this.bullets = [];
    }

    loop() {
        if ((this.state === 'PLAYING' || this.state === 'BOSS_DEATH_CINEMATIC') && !this.paused) {
            this.update();
            this.draw();
        } else {
            if (this.state !== 'MENU' && this.player) this.draw();
        }
        requestAnimationFrame(() => this.loop());
    }

    update() {
        if (!this.player) return;

        if (this.state === 'BOSS_DEATH_CINEMATIC') {
            window.timeScale = 0.2; 
            
            this.player.update();
            this.bullets.forEach(b => b.update());
            this.enemies.forEach(e => { if(!e.dead) e.update(this.enemies); });
            
            for (let i = this.particles.length - 1; i >= 0; i--) {
                let p = this.particles[i]; p.update();
                if (p.dead) { ObjectPool.releaseParticle(p); this.particles.splice(i, 1); }
            }
            for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
                let t = this.floatingTexts[i]; t.update();
                if (t.dead) this.floatingTexts.splice(i, 1);
            }
            
            let elapsed = Date.now() - this.cinematicStartTime;
            
            if (elapsed >= 3000 && !this.cinematicExplosionDone) {
                this.triggerCinematicExplosions();
                this.cinematicExplosionDone = true;
            }
            
            if (elapsed >= 3000) {
                let fadeProgress = (elapsed - 3000) / 2000;
                document.getElementById('fade-overlay').style.opacity = Math.min(1, fadeProgress);
            } else {
                document.getElementById('fade-overlay').style.opacity = 0;
            }
            
            if (elapsed >= 5000) {
                this.endCinematic();
            }
            
            return; 
        }

        window.timeScale = 1.0;
        document.getElementById('fade-overlay').style.opacity = 0;

        this.player.update();
        if(isHost) {
            this.manageWaves();
            this.manageThunder();
        }

        for (let i = this.bullets.length - 1; i >= 0; i--) {
            let b = this.bullets[i];
            b.update();
            if (b.dead) {
                ObjectPool.releaseBullet(b);
                this.bullets.splice(i, 1);
            }
        }

        // Se for Host, atualiza os Inimigos de verdade.
        if (isHost) {
            for (let i = this.enemies.length - 1; i >= 0; i--) {
                let e = this.enemies[i];
                e.update(this.enemies);
                if (e.dead) {
                    if (e.type !== 'boss' && e.type !== 'miniboss') ObjectPool.releaseEnemy(e);
                    this.enemies.splice(i, 1);
                    audioManager.playSfx('hit');
                    if (Math.random() < this.player.stats.soulChance) {
                        this.souls += 1;
                        this.updateSoulsUI();
                    }
                }
            }
        }

        // Enviar os dados do Host para o Guest (sincronizaÃ§Ã£o de rede a cada 50ms)
        if (isHost && isMultiplayer && conn && conn.open && Date.now() - this.lastNetworkSync > 50) {
            this.lastNetworkSync = Date.now();
            let networkEnemies = this.enemies.map(e => {
                return {
                    x: e.x, y: e.y, hp: e.hp, maxHp: e.maxHp, dead: e.dead,
                    width: e.width, height: e.height, shieldActive: e.shieldActive,
                    poisonActive: e.poisonActive, eType: e.type
                };
            });
            conn.send({
                type: 'host_state',
                wave: this.wave,
                enemies: networkEnemies
            });
        }

        for (let i = this.particles.length - 1; i >= 0; i--) {
            let p = this.particles[i];
            p.update();
            if (p.dead) {
                ObjectPool.releaseParticle(p);
                this.particles.splice(i, 1);
            }
        }

        for (let i = this.lightningEffects.length - 1; i >= 0; i--) {
            let l = this.lightningEffects[i];
            l.update();
            if (l.dead) this.lightningEffects.splice(i, 1);
        }
        
        for (let i = this.floatingTexts.length - 1; i >= 0; i--) {
            let t = this.floatingTexts[i];
            t.update();
            if (t.dead) this.floatingTexts.splice(i, 1);
        }
    }

    manageThunder() {
        const tier = this.player.perks.thunderbolt;
        if (tier > 0) {
            let intervalSeconds = (tier === 3) ? 8 : Math.max(2, 6 - (tier - 1)); 
            if (Date.now() - this.lastThunderTime > intervalSeconds * 1000) {
                const visibleEnemies = this.enemies.filter(e => e.y > 0 && e.y < this.height && e.x > 0 && e.x < this.width);
                let boltsToFire = (tier === 3) ? 2 : 1;
                let bossHitThisCycle = false;

                for (let k = 0; k < boltsToFire; k++) {
                    let hit = false; let targetX, targetY; let targetEnemy = null;
                    let hitChance = tier === 1 ? 0.4 : (tier === 2 ? 0.5 : 0.8);

                    if (visibleEnemies.length > 0 && Math.random() < hitChance) {
                        targetEnemy = visibleEnemies[Math.floor(Math.random() * visibleEnemies.length)];
                        targetX = targetEnemy.x + targetEnemy.width/2; targetY = targetEnemy.y; hit = true;
                    } else {
                        targetX = 100 + Math.random() * (this.width - 200); targetY = 650; hit = false;
                    }

                    if (hit && targetEnemy) {
                        if (tier === 3) {
                            let hitCount = 0;
                            let nearEnemies = visibleEnemies.filter(e => Math.abs((e.x + e.width/2) - targetX) < 60 && !e.dead);
                            nearEnemies.sort((a,b) => Math.abs((a.x + a.width/2) - targetX) - Math.abs((b.x + b.width/2) - targetX));
                            
                            for(let ne of nearEnemies) {
                                if(hitCount >= 2) break;
                                if(ne.type === 'boss' || ne.type === 'miniboss') {
                                    if(!bossHitThisCycle) {
                                        ne.takeDamage(ne.maxHp * 0.07);
                                        bossHitThisCycle = true;
                                        hitCount++;
                                    }
                                } else {
                                    ne.takeDamage(ne.hp + 10);
                                    hitCount++;
                                }
                            }
                            targetY = game.height; 
                        } else {
                            let pctDmg = tier === 1 ? 0.6 : 0.8;
                            let bossPct = tier === 1 ? 0.05 : 0.08;
                            let mult = (targetEnemy.type === 'boss' || targetEnemy.type === 'miniboss') ? bossPct : pctDmg;
                            targetEnemy.takeDamage(targetEnemy.hp * mult);
                        }
                    }
                    this.lightningEffects.push(new LightningBeam(targetX, targetY, tier === 3));
                    audioManager.playSfx('thunder');
                }
                this.lastThunderTime = Date.now();
            }
        }
    }

    manageWaves() {
        if (this.enemies.length === 0 && this.enemiesToSpawn <= 0) {
            this.state = 'UPGRADE_MENU';
            if (this.player && !this.player.manaShieldReady && this.player.perks.manaShield) {
                this.manaShieldPausedTime = this.player.manaShieldCooldown - Date.now();
            }
            this.showUpgradeMenu();
        }
        if (this.enemiesToSpawn > 0) {
            if (Date.now() - this.lastSpawnTime > 1000) { 
                this.spawnEnemy(); this.enemiesToSpawn--; this.lastSpawnTime = Date.now();
            }
        }
    }

    spawnEnemy(forcedX = null) {
        const x = forcedX !== null ? forcedX : Math.max(0, Math.min(this.width - 50, this.waveClusterX - 120 + Math.random() * 240));
        const y = -50;
        
        const types = ['triangulo', 'losango', 'redondo'];
        let type = types[Math.floor(Math.random() * types.length)];
        
        this.enemies.push(ObjectPool.getEnemy(x, y, type));
    }

    spawnBoss(isBigBoss) { this.enemies.push(new Boss(this.width/2 - 40, -100, isBigBoss)); }

    createParticle(x, y, color, size, duration = 500, speedMult = 1) {
        if (this.particles.length >= 2000) return; 
        this.particles.push(ObjectPool.getParticle(x, y, color, size, duration, speedMult));
    }
    
    addFloatingText(x, y, text, color = null) {
        const colors = ['red', '#4da6ff', '#00ff00']; 
        const c = color || colors[Math.floor(Math.random() * colors.length)];
        this.floatingTexts.push(new FloatingText(x, y, text, c));
    }

    showUpgradeMenu() {
        this.clearAllBullets();

        const menu = document.getElementById('upgrade-menu');
        const container = document.getElementById('upgrade-container');
        container.innerHTML = '';
        menu.classList.remove('hidden');

        let secondsLeft = 20;
        const timerText = document.getElementById('timer-text');
        const timerBar = document.getElementById('timer-bar');
        timerBar.style.width = '100%'; timerText.innerText = "20s";

        if (this.menuTimer) clearInterval(this.menuTimer);

        let chosenUpgrades = [];
        let createdCards = [];

        for (let i = 0; i < this.upgradeChoices; i++) {
            const card = document.createElement('div');
            card.className = 'upgrade-card card-locked';
            
            let selectedUpgrade = null;

            if (!chosenUpgrades.includes('teleport') && !this.player.perks.teleport && Math.random() < 0.015) {
                selectedUpgrade = UPGRADES_DB.legendary.find(u => u.id === 'teleport');
            } else if (!chosenUpgrades.includes('phoenix') && !this.player.perks.phoenix && Math.random() < 0.02) {
                selectedUpgrade = UPGRADES_DB.legendary.find(u => u.id === 'phoenix');
            } else if (!chosenUpgrades.includes('homing') && !maxTierCheck(this.player, 'homing', 3)) {
                let hc = this.player.perksCounts['homing'] || 0;
                let hChance = hc === 0 ? 0.06 : (hc === 1 ? 0.04 : 0.02);
                if (Math.random() < hChance) {
                    selectedUpgrade = UPGRADES_DB.uncommon.find(u => u.id === 'homing');
                }
            }

            if (!selectedUpgrade) {
                let rarityRoll = Math.random();
                let chosenPool = UPGRADES_DB.common; let rarityClass = 'rarity-common';
                let ignoreList = ['teleport', 'phoenix', 'homing'];

                if (rarityRoll > 0.90) { chosenPool = UPGRADES_DB.epic; rarityClass = 'rarity-epic'; }
                else if (rarityRoll > 0.65) { chosenPool = UPGRADES_DB.uncommon; rarityClass = 'rarity-uncommon'; }

                let validPool = chosenPool.filter(u => {
                    if (chosenUpgrades.includes(u.id)) return false;
                    if (ignoreList.includes(u.id)) return false;
                    
                    if (u.id === 'resonance' || u.id === 'resonance_plus') {
                        let totalAtkSpd = (this.player.perksCounts['resonance'] || 0) + (this.player.perksCounts['resonance_plus'] || 0);
                        if (totalAtkSpd >= 3) return false;
                    }
                    return !maxTierCheck(this.player, u.id, u.max);
                });

                if (validPool.length === 0) {
                     let allValid = [...UPGRADES_DB.common, ...UPGRADES_DB.uncommon, ...UPGRADES_DB.epic, ...UPGRADES_DB.legendary].filter(u => {
                        if (chosenUpgrades.includes(u.id)) return false;
                        if (ignoreList.includes(u.id)) return false;
                        if (u.id === 'resonance' || u.id === 'resonance_plus') {
                            let totalAtkSpd = (this.player.perksCounts['resonance'] || 0) + (this.player.perksCounts['resonance_plus'] || 0);
                            if (totalAtkSpd >= 3) return false;
                        }
                        return !maxTierCheck(this.player, u.id, u.max);
                    });
                     validPool = allValid.length > 0 ? allValid : UPGRADES_DB.common;
                }

                if (validPool.length > 0) {
                    let candidate = validPool[Math.floor(Math.random() * validPool.length)];
                    let currentCount = this.player.perksCounts[candidate.id] || 0;
                    
                    if (currentCount === 1 && Math.random() < 0.3) candidate = validPool[Math.floor(Math.random() * validPool.length)];
                    if (currentCount === 2 && candidate.id !== 'thunderbolt' && Math.random() < 0.4) candidate = validPool[Math.floor(Math.random() * validPool.length)];
                    
                    selectedUpgrade = candidate;
                }
            }
            
            if (!selectedUpgrade) selectedUpgrade = UPGRADES_DB.common.find(u => u.id === 'growth');
            chosenUpgrades.push(selectedUpgrade.id);
            
            let rClass = 'rarity-common';
            if (UPGRADES_DB.uncommon.find(u=>u.id === selectedUpgrade.id)) rClass = 'rarity-uncommon';
            else if (UPGRADES_DB.epic.find(u=>u.id === selectedUpgrade.id)) rClass = 'rarity-epic';
            else if (UPGRADES_DB.legendary.find(u=>u.id === selectedUpgrade.id)) rClass = 'rarity-legendary';
            card.classList.add(rClass);

            let count = this.player.perksCounts[selectedUpgrade.id] || 0;
            let tierText = "";
            if (selectedUpgrade.max > 3) tierText = `x${count}`;
            else if (selectedUpgrade.max === 1) tierText = "";
            else tierText = `${TEXTS[currentLang].tier} ${count + 1}`; 
            
            let dName = (currentLang === 'pt') ? selectedUpgrade.name_pt : selectedUpgrade.name_en;
            let dDesc = (currentLang === 'pt') ? selectedUpgrade.desc_pt : selectedUpgrade.desc_en;

            card.innerHTML = `<span class="card-tier">${tierText}</span><div class="card-title">${dName}</div><div class="card-desc">${dDesc}</div>`;
            
            const pickUpgrade = () => {
                clearInterval(this.menuTimer);
                if (card.classList.contains('card-locked')) return;
                
                audioManager.playWav('botton');
                
                selectedUpgrade.apply(this.player);
                this.player.perksCounts[selectedUpgrade.id] = (this.player.perksCounts[selectedUpgrade.id] || 0) + 1;

                menu.classList.add('hidden');
                if (this.player.perks.manaShield && !this.player.manaShieldReady) {
                    this.player.manaShieldCooldown = Date.now() + this.manaShieldPausedTime;
                }
                this.player.updateStatsUI();
                this.wave++; this.state = 'PLAYING'; 
                if(isHost) this.startWave();
            };

            card.onclick = pickUpgrade;
            createdCards.push(pickUpgrade); 
            container.appendChild(card);
        }

        this.menuTimer = setInterval(() => {
            secondsLeft--;
            timerText.innerText = secondsLeft + "s";
            timerBar.style.width = (secondsLeft / 20 * 100) + "%";
            
            if (secondsLeft <= 0) {
                const randomPick = createdCards[Math.floor(Math.random() * createdCards.length)];
                randomPick();
            }
        }, 1000);

        setTimeout(() => {
            const cards = document.querySelectorAll('.upgrade-card');
            cards.forEach(c => { c.classList.remove('card-locked'); c.classList.add('card-unlocked'); });
        }, 500);
    }

    draw() {
        ctx.fillStyle = CONFIG.colors.bg; ctx.fillRect(0, 0, this.width, this.height);
        
        ctx.save();
        if (this.state === 'BOSS_DEATH_CINEMATIC') {
            let elapsed = Date.now() - this.cinematicStartTime;
            let targetX = this.cinematicBoss.x + this.cinematicBoss.width/2;
            let targetY = this.cinematicBoss.y + this.cinematicBoss.height/2;
            
            let progress = Math.min(1, elapsed / 3000); 
            
            let shakeIntensity = elapsed < 3000 ? progress * 6 : 0;
            let shakeX = (Math.random() - 0.5) * shakeIntensity;
            let shakeY = (Math.random() - 0.5) * shakeIntensity;
            
            let zoom = 1 + (progress * 0.5); 
            
            let startCamX = this.width / 2;
            let startCamY = this.height / 2;
            let currentCamX = startCamX + (targetX - startCamX) * progress;
            let currentCamY = startCamY + (targetY - startCamY) * progress;
            
            ctx.translate(this.width/2, this.height/2);
            ctx.scale(zoom, zoom);
            ctx.translate(-currentCamX + shakeX, -currentCamY + shakeY);
        }

        if (this.showTeleportZonesUntil && Date.now() < this.showTeleportZonesUntil) {
            ctx.save();
            ctx.fillStyle = 'rgba(0, 255, 255, 0.15)';
            ctx.fillRect(0, 0, this.width / 6, this.height);
            ctx.fillRect(this.width * 5 / 6, 0, this.width / 6, this.height);
            
            ctx.fillStyle = 'cyan';
            ctx.font = '12px "Press Start 2P"';
            ctx.textAlign = 'center';
            if (Math.floor(Date.now() / 150) % 2 === 0) {
                ctx.fillText("AREA VALIDA", this.width / 12, this.height / 2);
                ctx.fillText("AREA VALIDA", this.width * 11 / 12, this.height / 2);
            }
            ctx.restore();
        }

        ctx.fillStyle = '#0a0a0a'; ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
        this.blocks.forEach(b => { ctx.fillRect(b.x, b.y, b.w, b.h); ctx.strokeRect(b.x, b.y, b.w, b.h); });
        
        if (this.player && this.state !== 'MENU' && this.state !== 'BOSS_DEATH_CINEMATIC') {
            const centerX = this.player.x + this.player.width / 2;
            const centerY = this.player.y + this.player.height / 2;
            const angle = Math.atan2(this.input.mouse.y - centerY, this.input.mouse.x - centerX);
            const endX = centerX + Math.cos(angle) * 2000; const endY = centerY + Math.sin(angle) * 2000;
            
            if (this.player.laserActive) {
                ctx.save();
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 25;
                ctx.lineCap = 'round';
                ctx.globalAlpha = 0.6 + Math.sin(Date.now() / 50) * 0.4; 
                ctx.beginPath(); ctx.moveTo(centerX, centerY); ctx.lineTo(endX, endY); ctx.stroke();
                
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 8;
                ctx.globalAlpha = 0.9;
                ctx.beginPath(); ctx.moveTo(centerX, centerY); ctx.lineTo(endX, endY); ctx.stroke();
                ctx.restore();
            } else {
                ctx.save(); ctx.strokeStyle = 'red'; ctx.lineWidth = 1; ctx.globalAlpha = 0.4; 
                ctx.beginPath(); ctx.moveTo(centerX, centerY); ctx.lineTo(endX, endY); ctx.stroke(); ctx.restore();
            }
        }

        this.player.draw(ctx);
        if(this.remotePlayer) this.remotePlayer.draw(ctx); // Desenhar Parceiro
        
        this.enemies.forEach(e => { if (!e.dead) e.draw(ctx); });
        this.bullets.forEach(b => b.draw(ctx));
        this.particles.forEach(p => p.draw(ctx));
        this.lightningEffects.forEach(l => l.draw(ctx));
        this.floatingTexts.forEach(t => t.draw(ctx));

        ctx.restore();

        if (this.state === 'BOSS_CONFIRM' || this.state === 'UPGRADE_MENU' || this.state === 'PAUSED') {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(0, 0, this.width, this.height);
        }
    }
}

class FloatingText {
    constructor(x, y, text, color) {
        this.x = x; this.y = y; this.text = text; this.color = color;
        this.vy = -1; this.spawnTime = Date.now(); this.duration = 500; this.dead = false;
    }
    update() {
        this.y += this.vy;
        if (Date.now() - this.spawnTime > this.duration) this.dead = true;
    }
    draw(ctx) {
        ctx.save(); ctx.font = '12px "Press Start 2P"'; ctx.fillStyle = this.color;
        let remaining = this.duration - (Date.now() - this.spawnTime);
        if (remaining < 150) ctx.globalAlpha = Math.max(0, remaining / 150);
        ctx.fillText(this.text, this.x, this.y); ctx.restore();
    }
}

class CompanionOrb {
    constructor(player) {
        this.player = player; this.x = player.x; this.y = player.y; this.lastShot = Date.now();
    }
    update() {
        let tier = this.player.perks.pursuingOrb;
        if (tier <= 0) return;
        let targetX = this.player.x + this.player.width + 25; let targetY = this.player.y + 10;
        this.x += (targetX - this.x) * 0.1; this.y += (targetY - this.y) * 0.1;

        let now = Date.now(); let currentFireRate = this.player.stats.fireRate; 
        if (game.state !== 'BOSS_DEATH_CINEMATIC' && now - this.lastShot > currentFireRate) {
            let onScreenEnemies = game.enemies.filter(e => e.y > 0 && e.y < game.height && !e.dead);
            if(onScreenEnemies.length > 0 && !this.player.laserActive) { this.shoot(tier); this.lastShot = now; }
        }
    }
    shoot(tier) {
        let nearest = null; let minDist = Infinity;
        for (let e of game.enemies) {
            if (e.dead) continue;
            let dist = Math.hypot(e.x - this.x, e.y - this.y);
            if (dist < minDist) { minDist = dist; nearest = e; }
        }
        if (nearest) {
            let angle = Math.atan2((nearest.y + nearest.height/2) - this.y, (nearest.x + nearest.width/2) - this.x);
            let dmg = this.player.stats.damage;
            if (Math.random() < this.player.stats.critChance) dmg *= this.player.stats.critDmg;
            if (this.player.hp < this.player.maxHp / 2) dmg *= 1.5;
            let bulletStats = { ...this.player.stats, speed: 1.75 };
            let finalDmg = tier === 3 ? dmg : this.player.stats.damage * 0.5;
            if (this.player.perks.homing > 0) bulletStats.homingTier = this.player.perks.homing;
            if (this.player.perks.chainLightning > 0) bulletStats.chainTier = this.player.perks.chainLightning;
            if (tier === 1) { bulletStats.speed = 0.85; bulletStats.projSize = 2; bulletStats.pierce = 0; } 
            else if (tier === 2) { bulletStats.speed = 1.75; bulletStats.projSize = 4; bulletStats.pierce = 0; } 
            else if (tier === 3) { bulletStats.color = 'white'; }
            if (this.player.perks.cold) bulletStats.isCold = true;

            let b = ObjectPool.getBullet(this.x, this.y, angle, finalDmg, true, bulletStats);
            game.bullets.push(b);
            audioManager.playSfx('shoot');
            
            // Sincronizar Orbe tambÃ©m se for Multiplayer
            if (isMultiplayer && conn && conn.open) {
                conn.send({
                    type: 'shoot',
                    x: this.x, y: this.y, angle: angle, damage: finalDmg, stats: bulletStats
                });
            }
        }
    }
    draw(ctx) {
        if (this.player.perks.pursuingOrb <= 0) return;
        ctx.fillStyle = '#4da6ff'; ctx.beginPath(); ctx.arc(this.x, this.y, 6, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke();
    }
}

class Player {
    constructor(x, y, charIndex) {
        this.x = x; this.y = y; this.width = 52; this.height = 69; 
        this.vx = 0; this.vy = 0; this.grounded = false; this.color = CONFIG.colors.player; this.charIndex = charIndex; 
        this.walkTimer = 0; this.hp = 100; this.maxHp = 100;
        
        this.stats = { speed: CONFIG.playerSpeed, jumpPower: CONFIG.jumpForce, damage: 10, fireRate: 1150, critChance: 0.05, critDmg: 2.0, lifesteal: 0, soulChance: 0.01, pierce: 0, projSize: 4, jumpsMax: 1, defense: 0 };
        this.jumpsLeft = 0; this.perksCounts = {}; 
        this.perks = { fragmentation: false, thunderbolt: 0, cold: false, pursuingOrb: 0, homing: 0, timeWarp: 0, multishot: false, execute: false, bouncing: false, manaShield: false, phoenix: false, swift: 0, chainLightning: 0, decimator: 0, poison: 0, teleport: false };
        this.manaShieldReady = false; this.manaShieldCooldown = 0;
        this.orb = new CompanionOrb(this); this.lastShot = 0; this.facing = 1; this.invulnUntil = 0;
        this.healingFatigueUntil = 0; 
        
        this.laserActive = false; this.laserTimer = 0; this.laserCooldown = 0; this.laserLastTick = 0;
        this.teleportCooldown = 0;
        this.updateStatsUI();
    }

    checkRect(r1, r2) {
        return r1.x < r2.x + r2.w && r1.x + r1.width > r2.x && r1.y < r2.y + r2.h && r1.y + r1.height > r2.y;
    }

    updateHpUI() {
        const pct = Math.max(0, Math.min(100, (this.hp / this.maxHp) * 100));
        document.getElementById('hp-bar').style.width = `${pct}%`;
        document.getElementById('hp-text').innerText = `${Math.ceil(this.hp)}/${this.maxHp}`;
        this.updateStatsUI();
    }

    updateStatsUI() {
        document.getElementById('stat-maxhp').innerText = this.maxHp;
        document.getElementById('stat-dmg').innerText = this.stats.damage.toFixed(1);
        let hitsPerSecond = 1000 / this.stats.fireRate;
        document.getElementById('stat-atkspd').innerText = hitsPerSecond.toFixed(2);
        document.getElementById('stat-critc').innerText = (this.stats.critChance * 100).toFixed(0);
        document.getElementById('stat-critd').innerText = (this.stats.critDmg * 100).toFixed(0);
        document.getElementById('stat-lifesteal').innerText = (this.stats.lifesteal * 100).toFixed(0);
    }

    activateTeleport() {
        if (!this.perks.teleport || Date.now() < this.teleportCooldown || game.state !== 'PLAYING') return;

        let limitZone = game.width / 6;
        let isLeft = this.x + this.width/2 < limitZone;
        let isRight = this.x + this.width/2 > game.width - limitZone;

        if (!isLeft && !isRight) {
            game.showTeleportZonesUntil = Date.now() + 1500;
            audioManager.playSfx('hit'); 
            return;
        }

        this.teleportCooldown = Date.now() + 300000;
        game.startTeleport(isLeft);
    }

    activateLaser() {
        if (this.perks.decimator > 0 && Date.now() >= this.laserCooldown && !this.laserActive && game.state === 'PLAYING') {
            this.laserActive = true;
            this.laserTimer = Date.now() + 4000;
            this.laserLastTick = Date.now();
            this.laserCooldown = Date.now() + 180000;
        }
    }

    fireLaserTick() {
        const centerX = this.x + this.width / 2;
        const centerY = this.y + this.height / 2;
        const angle = Math.atan2(game.input.mouse.y - centerY, game.input.mouse.x - centerX);
        const endX = centerX + Math.cos(angle) * 2000;
        const endY = centerY + Math.sin(angle) * 2000;

        const p1 = { x: centerX, y: centerY };
        const p2 = { x: endX, y: endY };

        game.enemies.forEach(e => {
            if (!e.dead && e.y > -50) {
                const ep = { x: e.x + e.width / 2, y: e.y + e.height / 2 };
                const dist = distToSegment(ep, p1, p2);
                
                if (dist < (25 / 2 + e.width / 2)) {
                    let isBoss = (e.type === 'boss' || e.type === 'miniboss');
                    let tier = this.perks.decimator;
                    let pct = 0;
                    
                    if (tier === 1) pct = isBoss ? 0.02 : 0.05;
                    else if (tier === 2) pct = isBoss ? 0.03 : 0.07;
                    else if (tier >= 3) pct = isBoss ? 0.04 : 0.10;

                    let dmg = e.maxHp * pct;
                    e.takeDamage(dmg);
                }
            }
        });
        audioManager.playSfx('laser');
    }

    update() {
        // Envio da rede constante a cada quadro para nÃ£o lagar
        if (isMultiplayer && conn && conn.open) {
            conn.send({
                type: 'player_update',
                x: this.x,
                y: this.y,
                facing: this.facing,
                hp: this.hp,
                maxHp: this.maxHp,
                charIndex: this.charIndex
            });
        }

        if (this.perks.manaShield && !this.manaShieldReady) {
            if (Date.now() > this.manaShieldCooldown) {
                this.manaShieldReady = true; document.getElementById('mana-shield-indicator').style.display='block'; audioManager.playSfx('select'); 
            }
        }

        let laserUI = document.getElementById('laser-ui');
        if (this.perks.decimator > 0) {
            laserUI.style.display = 'flex';
            if (this.laserActive || Date.now() < this.laserCooldown) {
                laserUI.style.opacity = 0.5;
                let cdRemaining = Math.ceil((this.laserCooldown - Date.now()) / 1000);
                if (this.laserActive) document.getElementById('laser-cd').innerText = "ATV";
                else document.getElementById('laser-cd').innerText = cdRemaining > 0 ? cdRemaining : "PRONTO";
            } else {
                laserUI.style.opacity = 1;
                document.getElementById('laser-cd').innerText = 'PRONTO';
            }
        }

        let tpUI = document.getElementById('teleport-ui');
        if (this.perks.teleport) {
            tpUI.style.display = 'flex';
            if (game.state === 'TELEPORTING' || Date.now() < this.teleportCooldown) {
                tpUI.style.opacity = 0.5;
                let cdRemaining = Math.ceil((this.teleportCooldown - Date.now()) / 1000);
                document.getElementById('teleport-cd').innerText = cdRemaining > 0 ? cdRemaining : "PRONTO";
            } else {
                tpUI.style.opacity = 1;
                document.getElementById('teleport-cd').innerText = 'PRONTO';
            }
        }

        if (game.state === 'TELEPORTING') return;

        let speedMult = 1.0;
        if (this.perks.swift > 0) speedMult += (this.perks.swift * 0.1); 

        if (game.input.keys['KeyA']) { this.vx = -this.stats.speed * speedMult; this.facing = -1; if(this.grounded) this.walkTimer += 0.2 * window.timeScale; }
        else if (game.input.keys['KeyD']) { this.vx = this.stats.speed * speedMult; this.facing = 1; if(this.grounded) this.walkTimer += 0.2 * window.timeScale; }
        else { this.vx *= CONFIG.friction; this.walkTimer = 0; }

        if (game.input.keys['Space']) {
            if (!this.jumpKeyHeld) { 
                if (this.grounded) { this.vy = -this.stats.jumpPower; this.grounded = false; this.jumpsLeft = this.stats.jumpsMax - 1; } 
                else if (this.jumpsLeft > 0) { this.vy = -this.stats.jumpPower; this.jumpsLeft--; }
                this.jumpKeyHeld = true;
            }
        } else { this.jumpKeyHeld = false; }

        this.x += this.vx * window.timeScale;
        for (let b of game.blocks) {
            if (this.checkRect(this, b)) {
                if (this.vx > 0) this.x = b.x - this.width;
                else if (this.vx < 0) this.x = b.x + b.w;
                this.vx = 0;
            }
        }

        this.vy += CONFIG.gravity * window.timeScale; 
        this.y += this.vy * window.timeScale; 
        this.grounded = false;
        
        for (let b of game.blocks) {
            if (this.checkRect(this, b)) {
                if (this.vy > 0) { this.y = b.y - this.height; this.vy = 0; this.grounded = true; } 
                else if (this.vy < 0) { this.y = b.y + b.h; this.vy = 0; }
            }
        }

        if (this.x < 0) this.x = 0;
        if (this.x + this.width > game.width) this.x = game.width - this.width;

        const now = Date.now();
        
        if (this.laserActive) {
            if (now > this.laserTimer) {
                this.laserActive = false;
            } else if (now - this.laserLastTick >= 500) {
                this.fireLaserTick();
                this.laserLastTick = now;
            }
        } else {
            if (game.state !== 'BOSS_DEATH_CINEMATIC' && now - this.lastShot > this.stats.fireRate) {
                this.shoot();
                this.lastShot = now;
            }
        }

        this.orb.update();
    }

    shoot() {
        const centerX = this.x + this.width / 2; const centerY = this.y + this.height / 2;
        const angle = Math.atan2(game.input.mouse.y - centerY, game.input.mouse.x - centerX);
        let dmg = this.stats.damage;
        if (this.hp < this.maxHp / 2) dmg *= 1.5;
        if (Math.random() < this.stats.critChance) dmg *= this.stats.critDmg;

        let bulletStats = { ...this.stats, speed: 1.75, homingTier: this.perks.homing, isCold: this.perks.cold, execute: this.perks.execute, bouncing: this.perks.bouncing, chainTier: this.perks.chainLightning };
        let b1 = ObjectPool.getBullet(centerX, centerY, angle, dmg, true, bulletStats);
        game.bullets.push(b1);
        
        // Sincronizar via rede
        if (isMultiplayer && conn && conn.open) {
            conn.send({ type: 'shoot', x: centerX, y: centerY, angle: angle, damage: dmg, stats: bulletStats });
        }
        
        if (this.perks.multishot && Math.random() < 0.2) {
             let offset = (Math.random() - 0.5) * 0.5; 
             let b2 = ObjectPool.getBullet(centerX, centerY, angle + offset, dmg, true, bulletStats);
             game.bullets.push(b2);
             
             if (isMultiplayer && conn && conn.open) {
                 conn.send({ type: 'shoot', x: centerX, y: centerY, angle: angle + offset, damage: dmg, stats: bulletStats });
             }
        }
        audioManager.playSfx('shoot');
    }

    takeDamage(amount, isBossAttack = false) {
        if (Date.now() < this.invulnUntil) return;

        if (this.manaShieldReady) {
            this.manaShieldReady = false; this.manaShieldCooldown = Date.now() + 20000; 
            document.getElementById('mana-shield-indicator').style.display='none';
            game.addFloatingText(this.x, this.y - 20, TEXTS[currentLang].blocked, "#4dff4d");
            audioManager.playSfx('shatter'); this.invulnUntil = Date.now() + 3000; return;
        }

        let finalDamage = amount * (1 - this.stats.defense);
        const maxPctDamage = isBossAttack ? 0.20 : 0.15;
        const capLimit = this.maxHp * maxPctDamage;
        if (finalDamage > capLimit) finalDamage = capLimit;

        this.hp -= finalDamage; 
        this.updateHpUI(); 
        this.invulnUntil = Date.now() + 1000; 
        this.healingFatigueUntil = Date.now() + 4000;

        game.addFloatingText(this.x, this.y, Math.round(finalDamage));

        if (this.hp <= 0) {
            if (this.perks.phoenix) {
                this.perks.phoenix = false; document.getElementById('phoenix-indicator').style.display='none';
                this.hp = this.maxHp * 0.40; this.updateHpUI(); 
                audioManager.playSfx('phoenix');
                game.addFloatingText(this.x, this.y - 40, TEXTS[currentLang].revived, "gold");

                game.enemies.forEach(e => {
                     if (e.type !== 'boss' && e.type !== 'miniboss') { 
                         e.takeDamage(9999);
                         game.createParticle(e.x, e.y, 'gold', 10);
                     }
                });
                game.state = 'PLAYING'; this.invulnUntil = Date.now() + 2000; return;
            }

            game.state = 'GAME_OVER';
            document.getElementById('final-wave').innerText = game.wave;
            document.getElementById('game-over-menu').classList.remove('hidden');
            audioManager.play('main');
        }
    }

    draw(ctx) {
        if (Date.now() < this.invulnUntil && Math.floor(Date.now() / 100) % 2 === 0) return;
        if (this.manaShieldReady) {
            ctx.save(); ctx.globalAlpha = 0.3; ctx.fillStyle = '#4dff4d'; ctx.beginPath(); ctx.arc(this.x + this.width/2, this.y + this.height/2, 40, 0, Math.PI * 2); ctx.fill(); ctx.restore();
        }

        const imgKey = `mage${this.charIndex}`; const img = ASSETS.images[imgKey];
        let bobY = Math.sin(this.walkTimer) * 3;

        // Inverter sprite de acordo com direÃ§Ã£o (facing)
        ctx.save();
        if (this.facing === -1) {
            ctx.translate(this.x + this.width / 2, this.y + bobY);
            ctx.scale(-1, 1);
            if (img && img.complete && img.naturalHeight !== 0) ctx.drawImage(img, -this.width / 2, 0, this.width, this.height);
            else { ctx.fillStyle = this.color; ctx.fillRect(-this.width / 2, 0, this.width, this.height); }
        } else {
            if (img && img.complete && img.naturalHeight !== 0) ctx.drawImage(img, this.x, this.y + bobY, this.width, this.height);
            else { ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y + bobY, this.width, this.height); }
        }
        ctx.restore();

        this.orb.draw(ctx);
        
        // Desenha a barra de vida se for um parceiro remoto ou tiver machucado
        if (this !== game.player || this.hp < this.maxHp) {
             ctx.fillStyle = 'red'; ctx.fillRect(this.x, this.y - 10, this.width, 4);
             ctx.fillStyle = '#00ff00'; ctx.fillRect(this.x, this.y - 10, this.width * (this.hp / this.maxHp), 4);
        }
    }
}

class Enemy {
    constructor(x, y, type) { this.reset(x, y, type); }
    
    reset(x, y, type) {
        this.x = x; this.y = y; this.width = 35; this.height = 35; this.type = type; this.dead = false;
        this.escalaVisual = 1.8; 
        
        let hpBaseBruto = CONFIG.baseEnemyHP;
        let hpMult = 1 + (game.wave * 0.15) + Math.pow(game.wave / 10, 2); 
        
        let perkHpBonus = 0;
        if (game && game.player) {
            const p = game.player;
            if (p.perks.pursuingOrb === 1) perkHpBonus += 0.10;
            else if (p.perks.pursuingOrb === 2) perkHpBonus += 0.15;
            else if (p.perks.pursuingOrb >= 3) perkHpBonus += 0.20;

            if (p.perks.thunderbolt === 1) perkHpBonus += 0.10;
            else if (p.perks.thunderbolt === 2) perkHpBonus += 0.15;
            else if (p.perks.thunderbolt >= 3) perkHpBonus += 0.20;

            if (p.perks.chainLightning === 1) perkHpBonus += 0.05;
            else if (p.perks.chainLightning === 2) perkHpBonus += 0.10;
            else if (p.perks.chainLightning >= 3) perkHpBonus += 0.15;

            let resCount = p.perksCounts['resonance'] || 0;
            let resPlusCount = p.perksCounts['resonance_plus'] || 0;
            perkHpBonus += (resCount * 0.03) + (resPlusCount * 0.05);
        }
        let perkMultiplier = 1 + perkHpBonus;

        let hpEscalonadoTotal = hpBaseBruto * hpMult * perkMultiplier;
        
        this.hp = hpEscalonadoTotal; 
        this.maxHp = this.hp;
        
        this.targetY = 50 + Math.random() * 200; this.anchorX = x; this.speed = 0.5; this.movePhase = Math.random() * Math.PI * 2; 
        
        let leechPenalty = (game && game.player && game.player.stats.lifesteal > 0) ? 1.3 : 1.0;
        this.damage = getEnemyBaseDamage(game.wave) * leechPenalty;
        
        this.lastHitTime = 0; this.coldStacks = 0; this.coldUntil = 0; this.lastHitDamage = 0;
        this.lastShootTime = Date.now() - 2000 + Math.random() * 500;
        
        this.poisonStacks = 0; this.poisonActive = false; this.poisonEndTime = 0; this.poisonLastTick = 0;
    }

    tickDebuffs() {
        if (this.shieldActive) return;

        if (this.poisonActive) {
            if (Date.now() > this.poisonEndTime) {
                this.poisonActive = false;
            } else if (Date.now() - this.poisonLastTick >= 1000) {
                this.poisonLastTick = Date.now();
                let pTier = game.player.perks.poison;
                let pBase = game.player.stats.damage;
                let dmg = 0;
                if (pTier === 1) dmg = pBase * 0.15;
                else if (pTier === 2) dmg = pBase * 0.20;
                else if (pTier >= 3) dmg = (pBase * 0.25) + (this.maxHp * 0.02);
                
                this.hp -= dmg;
                game.addFloatingText(this.x, this.y, Math.round(dmg), "#00ff00");
                if (this.hp <= 0) this.die();
            }
        }
    }

    update(allEnemies) {
        let timeWarpFactor = 1.0; const twTier = game.player.perks.timeWarp;
        if (twTier === 1) timeWarpFactor = 0.9; if (twTier === 2) timeWarpFactor = 0.85; if (twTier === 3) timeWarpFactor = 0.8;

        if (this.y < this.targetY) this.y += 1.4 * timeWarpFactor * window.timeScale; 
        else this.y += Math.sin(Date.now() / 500 + this.movePhase) * 0.2 * timeWarpFactor * window.timeScale;

        const time = Date.now() / 1000; let desiredX = this.anchorX + Math.sin(time + this.movePhase) * 80;
        this.x += ((desiredX - this.x) * 0.035) * timeWarpFactor * window.timeScale;

        let separationX = 0; let separationY = 0; let count = 0;
        if (allEnemies) {
            for (let other of allEnemies) {
                if (other === this || other.dead) continue;
                if (Math.abs(this.x - other.x) > 50) continue; 
                const dist = Math.hypot(this.x - other.x, this.y - other.y);
                if (dist < 50 && dist > 0) { separationX += (this.x - other.x) / dist; separationY += (this.y - other.y) / dist; count++; }
            }
        }
        if (count > 0) { this.x += separationX * 0.35 * timeWarpFactor * window.timeScale; this.y += separationY * 0.35 * timeWarpFactor * window.timeScale; }
        
        const limiteMetadeTela = game.height / 2;
        const distAoPlayer = Math.hypot((game.player.x - this.x), (game.player.y - this.y));
        
        if (this.y > limiteMetadeTela) {
            this.y -= 2.5 * timeWarpFactor * window.timeScale; 
        } else if (distAoPlayer < 250) {
            this.y -= 2.0 * timeWarpFactor * window.timeScale; 
        }

        this.x = Math.max(0, Math.min(game.width - this.width, this.x));

        let fireRateMod = 1.0;
        if (Date.now() < this.coldUntil) fireRateMod = Math.pow(0.8, this.coldStacks); else this.coldStacks = 0;

        let shootInterval = 2300 / fireRateMod;
        if (game.state !== 'BOSS_DEATH_CINEMATIC' && Date.now() - this.lastShootTime > shootInterval) { this.shoot(); this.lastShootTime = Date.now(); }

        this.tickDebuffs();
    }

    shoot() {
        const angle = Math.atan2((game.player.y + 20) - this.y, (game.player.x + 15) - this.x);
        const possibleColors = ['red', '#4da6ff', '#800080', '#00ff00']; const bulletColor = possibleColors[Math.floor(Math.random() * possibleColors.length)];
        let isBossAtk = (this.type === 'boss' || this.type === 'miniboss');
        game.bullets.push(ObjectPool.getBullet(this.x + 15, this.y + 15, angle, this.damage, false, { speed: 1.0, color: bulletColor, isBossAttack: isBossAtk }));
    }

    takeDamage(amount) {
        // Apenas o Host calcula os danos se estiver em multiplayer
        if(isMultiplayer && !isHost) return;

        if (this.shieldActive) {
            game.addFloatingText(this.x + this.width/2, this.y - 10, TEXTS[currentLang].blocked, "#4dff4d");
            return;
        }

        if (game.player.perks.execute && (this.hp / this.maxHp) < 0.15 && this.type !== 'boss' && this.type !== 'miniboss') {
            amount *= 2; game.createParticle(this.x, this.y, 'red', 5);
        }

        if (game.player.perks.poison > 0 && !this.poisonActive && this.poisonStacks < 2 && amount > 0) {
            let pChance = game.player.perks.poison === 1 ? 0.10 : (game.player.perks.poison === 2 ? 0.15 : 0.20);
            if (Math.random() < pChance) {
                this.poisonActive = true;
                this.poisonEndTime = Date.now() + 5000;
                this.poisonLastTick = Date.now();
                this.poisonStacks++;
            }
        }

        this.lastHitDamage = amount; 
        this.hp -= amount; this.lastHitTime = Date.now();
        game.addFloatingText(this.x, this.y, Math.round(amount));

        if (this.hp <= 0) this.die();
    }
    
    applyCold() { 
        if (this.shieldActive) return;
        this.coldStacks++; this.coldUntil = Date.now() + 8000; 
    }

    die() {
        if (this.dead) return;
        this.dead = true;
        for(let i=0; i<3; i++) game.createParticle(this.x + 15, this.y + 15, 'white', 5);
        if (game.player.perks.fragmentation) {
            for(let i=0; i<4; i++) {
                let ang = Math.random() * Math.PI * 2;
                game.bullets.push(ObjectPool.getBullet(this.x + 15, this.y + 15, ang, 0, true, { speed: 2.0, projSize: 3, isFragment: true }));
            }
        }

        if (game.player.stats.lifesteal > 0) {
            let heal = this.lastHitDamage * game.player.stats.lifesteal;
            let maxHeal = game.player.maxHp * 0.02; 
            heal = Math.min(heal, maxHeal);
            
            if (Date.now() < game.player.healingFatigueUntil) heal *= 0.3;

            game.player.hp = Math.min(game.player.maxHp, game.player.hp + heal);
            game.player.updateHpUI();
            if(heal > 1) game.addFloatingText(this.x, this.y - 15, `+${heal.toFixed(0)}`, "#00ff00");
        }
    }

    draw(ctx) {
        let img = ASSETS.images[this.type];
        
        ctx.save();
        if (this.poisonActive) {
            ctx.filter = 'sepia(1) hue-rotate(80deg) saturate(4)';
        }

        if (img && img.complete && img.naturalHeight !== 0) {
            let tamanhoVisual = this.width * this.escalaVisual;
            let offsetCentralizado = (tamanhoVisual - this.width) / 2;

            if (Date.now() - this.lastHitTime < 100) ctx.globalAlpha = 0.5;
            
            ctx.drawImage(img, this.x - offsetCentralizado, this.y - offsetCentralizado, tamanhoVisual, tamanhoVisual);
            ctx.restore();
            
            ctx.fillStyle = 'red'; ctx.fillRect(this.x, this.y - 8, this.width, 3);
            ctx.fillStyle = 'green'; ctx.fillRect(this.x, this.y - 8, this.width * (this.hp/this.maxHp), 3);
        } else {
            let displayColor = (Date.now() - this.lastHitTime < 100) ? 'white' : '#ccc';
            ctx.fillStyle = displayColor;
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x + this.width, this.y); ctx.lineTo(this.x + this.width / 2, this.y + this.height); ctx.fill();
            ctx.restore();
        }
    }
}

class Boss extends Enemy {
    constructor(x, y, isBigBoss) {
        super(x, y, isBigBoss ? 'boss' : 'miniboss');
        this.width = 69; this.height = 86; this.isBigBoss = isBigBoss; 
        
        this.escalaVisual = 2.0; 
        
        let hpBase = isBigBoss ? CONFIG.baseEnemyHP * 12 : CONFIG.baseEnemyHP * 7;
        let hpMult = 1 + (game.wave * 0.15) + Math.pow(game.wave / 10, 2); 
        
        let perkHpBonus = 0;
        if (game && game.player) {
            const p = game.player;
            if (p.perks.pursuingOrb === 1) perkHpBonus += 0.10;
            else if (p.perks.pursuingOrb === 2) perkHpBonus += 0.15;
            else if (p.perks.pursuingOrb >= 3) perkHpBonus += 0.20;

            if (p.perks.thunderbolt === 1) perkHpBonus += 0.10;
            else if (p.perks.thunderbolt === 2) perkHpBonus += 0.15;
            else if (p.perks.thunderbolt >= 3) perkHpBonus += 0.20;

            if (p.perks.chainLightning === 1) perkHpBonus += 0.05;
            else if (p.perks.chainLightning === 2) perkHpBonus += 0.10;
            else if (p.perks.chainLightning >= 3) perkHpBonus += 0.15;

            let resCount = p.perksCounts['resonance'] || 0;
            let resPlusCount = p.perksCounts['resonance_plus'] || 0;
            perkHpBonus += (resCount * 0.03) + (resPlusCount * 0.05);
        }
        let perkMultiplier = 1 + perkHpBonus;

        let hpTotalBruto = hpBase * hpMult * perkMultiplier;
        
        this.hp = hpTotalBruto * 0.80;
        this.maxHp = this.hp;
        
        this.lastSummonTime = Date.now(); this.colorUntil = 0; this.lastShootTime = Date.now();
        this.anchorX = game.width / 2 - 30; this.targetY = 100; this.moveSpeedLat = 0.028;
        
        let leechPenalty = (game && game.player && game.player.stats.lifesteal > 0) ? 1.3 : 1.0;
        this.damage = getEnemyBaseDamage(game.wave) * 1.5 * leechPenalty;

        this.shieldActive = false;
        this.lastShieldTime = Date.now();
    }

    update(allEnemies) {
        let timeWarpFactor = 1.0; const twTier = game.player.perks.timeWarp;
        if (twTier === 1) timeWarpFactor = 0.9; if (twTier === 2) timeWarpFactor = 0.85; if (twTier === 3) timeWarpFactor = 0.8;

        const time = Date.now() / 2000; const waveX = Math.sin(time) * 250; 
        let desiredX = this.anchorX + waveX;
        this.x += ((desiredX - this.x) * this.moveSpeedLat) * timeWarpFactor * window.timeScale;
        this.y += ((this.targetY - this.y) * 0.035 + Math.sin(Date.now()/300)*0.5) * timeWarpFactor * window.timeScale;
        
        if (this.y > game.height / 2.5) {
            this.y -= 1.5 * timeWarpFactor * window.timeScale;
        }

        let canShield = (this.isBigBoss && game.wave >= 20) || (!this.isBigBoss && game.wave >= 15);
        if (canShield) {
            let shieldDuration = this.isBigBoss ? 10000 : 5000;
            if (this.shieldActive) {
                if (Date.now() - this.lastShieldTime > shieldDuration) {
                    this.shieldActive = false;
                    this.lastShieldTime = Date.now(); 
                }
            } else {
                if (Date.now() - this.lastShieldTime > 30000) { 
                    this.shieldActive = true;
                    this.lastShieldTime = Date.now();
                }
            }
        }

        if (game.state !== 'BOSS_DEATH_CINEMATIC' && Date.now() - this.lastSummonTime > 7000 / timeWarpFactor) { 
            this.summonMinions(); 
            this.lastSummonTime = Date.now(); 
        }

        let fireInterval = 1500 / timeWarpFactor;
        let fireRateMod = 1.0;
        if (Date.now() < this.coldUntil) fireRateMod = Math.pow(0.8, this.coldStacks);
        fireInterval /= fireRateMod;

        if (game.state !== 'BOSS_DEATH_CINEMATIC' && Date.now() - this.lastShootTime > fireInterval) { this.bossAttack(); this.lastShootTime = Date.now(); }

        this.tickDebuffs();
    }

    bossAttack() {
        const centerX = this.x + this.width/2; const centerY = this.y + this.height/2;
        for(let i=0; i<4; i++) {
             const angle = Math.atan2((game.player.y + 20) - centerY, (game.player.x + 15) - centerX) + (i-1.5)*0.2;
             game.bullets.push(ObjectPool.getBullet(centerX, centerY, angle, this.damage, false, { speed: 1.3, isBossAttack: true }));
        }
    }

    summonMinions() { 
        let minionCount = game.enemies.filter(e => e.type !== 'boss' && e.type !== 'miniboss').length;
        if (minionCount >= 4) return; 

        this.colorUntil = Date.now() + 1000; 
        game.spawnEnemy(this.x + (Math.random() > 0.5 ? -40 : 100)); 
    }

    die() {
        if (game.state === 'BOSS_DEATH_CINEMATIC') return; 
        
        if (game.player.stats.lifesteal > 0) {
            let heal = this.lastHitDamage * game.player.stats.lifesteal;
            let maxHeal = game.player.maxHp * 0.02; 
            heal = Math.min(heal, maxHeal);
            
            if (Date.now() < game.player.healingFatigueUntil) heal *= 0.3;

            game.player.hp = Math.min(game.player.maxHp, game.player.hp + heal);
            game.player.updateHpUI();
            if(heal > 1) game.addFloatingText(this.x, this.y - 15, `+${heal.toFixed(0)}`, "#00ff00");
        }

        game.startBossDeathCinematic(this);
    }

    draw(ctx) {
        let img = ASSETS.images[this.type];
        
        ctx.save();
        if (this.poisonActive) {
            ctx.filter = 'sepia(1) hue-rotate(80deg) saturate(4)';
        }

        if (img && img.complete && img.naturalHeight !== 0) {
            let tamanhoVisual = this.width * this.escalaVisual;
            let offsetCentralizado = (tamanhoVisual - this.width) / 2;

            if (Date.now() - this.lastHitTime < 100 || Date.now() < this.colorUntil) ctx.globalAlpha = 0.5;
            
            ctx.drawImage(img, this.x - offsetCentralizado, this.y - offsetCentralizado, tamanhoVisual, tamanhoVisual);
            
            if (this.shieldActive) {
                ctx.save(); 
                ctx.globalAlpha = 0.3; 
                ctx.fillStyle = '#4dff4d'; 
                ctx.beginPath(); 
                ctx.arc(this.x + this.width/2, this.y + this.height/2, 60, 0, Math.PI * 2); 
                ctx.fill(); 
                ctx.restore();
            }
            
            ctx.restore();
            
            ctx.fillStyle = 'red'; ctx.fillRect(this.x - 10, this.y - 25, this.width + 20, 8);
            ctx.fillStyle = '#bf00ff'; ctx.fillRect(this.x - 10, this.y - 25, (this.width + 20) * (this.hp / this.maxHp), 8);
        } else {
            ctx.fillStyle = '#444';
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.x + this.width, this.y); ctx.lineTo(this.x + this.width / 2, this.y + this.height); ctx.fill();
            ctx.restore();
        }
    }
}

class Projectile {
    constructor(x, y, angle, damage, isPlayer, stats = {}) { this.reset(x, y, angle, damage, isPlayer, stats); }
    
    reset(x, y, angle, damage, isPlayer, stats = {}) {
        this.x = x; this.y = y; this.isPlayer = isPlayer;
        let speedMod = 1.0;
        if (!isPlayer) {
            const twTier = game.player.perks.timeWarp;
            if (twTier === 1) speedMod = 0.9; if (twTier === 2) speedMod = 0.85; if (twTier === 3) speedMod = 0.8;
        }

        let baseSpeed = isPlayer ? 1.75 : (stats.speed || 1.0);
        this.speed = baseSpeed * speedMod;
        this.vx = Math.cos(angle) * this.speed; this.vy = Math.sin(angle) * this.speed; this.damage = damage;
        this.dead = false; this.radius = isPlayer ? (stats.projSize || 4) : 4; this.pierce = stats.pierce || 0; this.isFragment = stats.isFragment || false;
        this.homingTier = stats.homingTier || 0; this.isCold = stats.isCold || false; this.canBounce = stats.bouncing || false; this.bouncesLeft = this.canBounce ? 1 : 0;
        this.chainTier = stats.chainTier || 0; this.hasChained = false;
        
        this.isBossAttack = stats.isBossAttack || false;

        this.isHomingActive = false; this.target = null;
        
        if (this.isPlayer && this.homingTier > 0) {
            let chance = this.homingTier === 1 ? 0.4 : (this.homingTier === 2 ? 0.65 : 1.00);
            if (Math.random() < chance) {
                this.isHomingActive = true;
                let bestDist = 600; 
                
                game.enemies.forEach(e => {
                    if(e.y > -50 && e.y < game.height && e.x > 0 && e.x < game.width && !e.dead) {
                        let d = Math.hypot(e.x - this.x, e.y - this.y);
                        let angleToEnemy = Math.atan2((e.y + e.height/2) - this.y, (e.x + e.width/2) - this.x);
                        let angleDiff = Math.abs(angleToEnemy - angle);
                        
                        while(angleDiff > Math.PI) angleDiff -= Math.PI*2;
                        while(angleDiff < -Math.PI) angleDiff += Math.PI*2;
                        angleDiff = Math.abs(angleDiff);

                        if (angleDiff < Math.PI / 3 && d < bestDist) { 
                            bestDist = d;
                            this.target = e;
                        }
                    }
                });
                if (!this.target) this.isHomingActive = false;
            }
        }
        
        this.color = isPlayer ? (stats.color || 'white') : (stats.color || 'red');
        this.history = []; this.frameCount = 0; 
    }

    update() {
        this.frameCount++;
        if (this.frameCount % 3 === 0) {
            this.history.push({x: this.x, y: this.y});
            let maxHistory = this.isPlayer ? 10 : 5; 
            if (this.history.length > maxHistory) this.history.shift(); 
        }

        if (this.isHomingActive && this.target && !this.target.dead) {
            let angleToTarget = Math.atan2((this.target.y + this.target.height/2) - this.y, (this.target.x + this.target.width/2) - this.x);
            let currentAngle = Math.atan2(this.vy, this.vx);
            
            let angleDiff = angleToTarget - currentAngle;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            
            let turnRate = this.homingTier * 0.08;
            
            if (Math.abs(angleDiff) < turnRate) {
                currentAngle = angleToTarget;
            } else {
                currentAngle += Math.sign(angleDiff) * turnRate;
            }

            if (Math.abs(angleDiff) > Math.PI / 1.5) { 
                this.isHomingActive = false;
            } else {
                this.vx = Math.cos(currentAngle) * this.speed;
                this.vy = Math.sin(currentAngle) * this.speed;
            }
        } else {
            this.isHomingActive = false; 
        }

        this.x += this.vx * window.timeScale; 
        this.y += this.vy * window.timeScale;

        if (this.x < 0 || this.x > game.width) {
            if (this.isPlayer && this.bouncesLeft > 0) {
                this.vx = -this.vx; this.bouncesLeft--; this.x = Math.max(0, Math.min(game.width, this.x)); audioManager.playSfx('shatter'); 
            } else this.dead = true;
        }
        if (this.y < 0) this.dead = true;

        let hitBlock = false; let blockHit = null;
        for (let b of game.blocks) {
            if (this.x > b.x && this.x < b.x + b.w && this.y > b.y && this.y < b.y + b.h) { hitBlock = true; blockHit = b; break; }
        }
        
        if (hitBlock) {
             if (this.isPlayer && this.bouncesLeft > 0) {
                 let prevY = this.y - this.vy * window.timeScale;
                 if (prevY <= blockHit.y || prevY >= blockHit.y + blockHit.h) this.vy = -this.vy; else this.vx = -this.vx;
                 this.bouncesLeft--; audioManager.playSfx('shatter');
             } else { this.shatter(); return; }
        }
        
        if (this.y > game.height) { this.shatter(); return; }

        if (this.isPlayer) {
            game.enemies.forEach(e => {
                if (!e.dead && e.y > -20 && this.checkCollision(e)) {
                    if (this.isFragment) {
                        if (e.type === 'boss' || e.type === 'miniboss') { this.dead = true; return; }
                        e.takeDamage(e.maxHp * (0.10 + Math.random() * 0.25)); this.dead = true;
                    } else {
                        e.takeDamage(this.damage); if (this.isCold) e.applyCold();
                        if (this.chainTier > 0 && !this.hasChained) {
                            let chainChance = this.chainTier === 1 ? 0.3 : (this.chainTier === 2 ? 0.5 : 1.0);
                            if (Math.random() < chainChance) {
                                let nextTarget = null; let minD = 400; 
                                game.enemies.forEach(other => {
                                    if (other !== e && !other.dead && other.y > 0) {
                                        let d = Math.hypot(other.x - e.x, other.y - e.y);
                                        if (d < minD) { minD = d; nextTarget = other; }
                                    }
                                });
                                if (nextTarget) {
                                    this.hasChained = true; this.x = e.x + e.width/2; this.y = e.y + e.height/2;
                                    let ang = Math.atan2((nextTarget.y + nextTarget.height/2) - this.y, (nextTarget.x + nextTarget.width/2) - this.x);
                                    this.vx = Math.cos(ang) * this.speed; this.vy = Math.sin(ang) * this.speed; 
                                    
                                    if (this.chainTier === 3) this.damage *= 0.5;
                                    
                                    return; 
                                }
                            }
                        }
                        if (this.pierce > 0) this.pierce--; else this.dead = true;
                    }
                }
            });
        } else {
            if (this.checkCollision(game.player)) { game.player.takeDamage(this.damage, this.isBossAttack); this.dead = true; }
        }
    }

    shatter() {
        this.dead = true;
        for(let i=0; i<3; i++) game.createParticle(this.x, this.y, this.color, 3 + Math.random() * 3);
        audioManager.playSfx('shatter');
    }

    checkCollision(rect) {
        return (this.x > rect.x && this.x < rect.x + rect.width && this.y > rect.y && this.y < rect.y + rect.height);
    }

    draw(ctx) {
        ctx.save(); ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        if (this.history.length > 1) {
            for (let i = 0; i < this.history.length - 1; i++) {
                const p1 = this.history[i]; const p2 = this.history[i+1]; const alpha = (i / this.history.length);
                let maxAlpha = this.isPlayer ? 0.7 : 0.49; ctx.globalAlpha = alpha * maxAlpha;
                ctx.strokeStyle = this.color; ctx.lineWidth = this.radius * 1.5;
                ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
            }
        }
        ctx.restore();
        ctx.fillStyle = '#ffffff'; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
        ctx.strokeStyle = this.color; ctx.lineWidth = 1.5; ctx.stroke();
    }
}

class Particle {
    constructor(x, y, color, size, duration, speedMult = 1) { this.reset(x, y, color, size, duration, speedMult); }
    reset(x, y, color, size, duration = 500, speedMult = 1) {
        this.x = x; this.y = y; 
        this.vx = (Math.random() - 0.5) * 5 * speedMult; 
        this.vy = (Math.random() - 0.5) * 5 * speedMult;
        this.spawnTime = Date.now(); this.duration = duration; this.size = size; this.color = color; this.dead = false;
    }
    update() {
        this.x += this.vx * window.timeScale; 
        this.y += this.vy * window.timeScale; 
        this.size *= (1 - 0.05 * window.timeScale); 
        if (Date.now() - this.spawnTime > this.duration) this.dead = true;
    }
    draw(ctx) { ctx.fillStyle = this.color; ctx.fillRect(this.x, this.y, this.size, this.size); }
}

class LightningBeam {
    constructor(targetX, targetY, isThick) { this.x = targetX; this.y = targetY; this.spawnTime = Date.now(); this.duration = 333; this.dead = false; this.isThick = isThick; }
    update() { if (Date.now() - this.spawnTime > this.duration) this.dead = true; }
    draw(ctx) {
        let remaining = this.duration - (Date.now() - this.spawnTime); const opacity = Math.max(0, remaining / this.duration);
        ctx.save(); ctx.globalAlpha = opacity; let width = this.isThick ? 16 : 10;
        ctx.strokeStyle = '#ffff00'; ctx.lineWidth = width; ctx.beginPath(); ctx.moveTo(this.x, 0); ctx.lineTo(this.x, this.y); ctx.stroke();
        ctx.strokeStyle = 'white'; ctx.lineWidth = width / 3; ctx.beginPath(); ctx.moveTo(this.x, 0); ctx.lineTo(this.x, this.y); ctx.stroke();
        ctx.restore();
    }
}

/**
 * STARTUP LOGIC
 */
function initGame() {
    localStorage.setItem('unlockedChars', '[1]');
    setLanguage('pt'); 
    game = new Game();
    document.getElementById('volume-slider').value = audioManager.globalVolume; 
    audioManager.play('main');
    
    // Iniciar a lÃ³gica do servidor PeerJS P2P
    initMultiplayer();
    
    const select = document.getElementById('char-selection');
    const chars = [{ id: 1, name: 'Default', cost: 0, unlocked: true }, { id: 2, name: 'Void', cost: 100, unlocked: false }, { id: 3, name: 'Crazy', cost: 200, unlocked: false }];
    const unlockedData = JSON.parse(localStorage.getItem('unlockedChars') || '[1]');
    
    chars.forEach((c, index) => {
        const isUnlocked = unlockedData.includes(c.id); const el = document.createElement('div');
        el.className = `char-card ${isUnlocked ? '' : 'char-locked'}`; if (index === 0) el.classList.add('selected');
        
        el.innerHTML = `<img src="Assets/mage${c.id}.png" style="width:64px;height:64px;display:block;margin:0 auto;object-fit:contain;" alt="Mage ${c.id}">
            <p>${c.name}</p>${!isUnlocked ? `<p style="color:#4da6ff;font-size:10px">${c.cost} Souls</p>` : ''}`;
            
        el.onclick = () => {
            audioManager.playWav('botton'); 
            if (audioManager.current && audioManager.current.paused) audioManager.play('main');
            if (isUnlocked) { document.querySelectorAll('.char-card').forEach(x => x.classList.remove('selected')); el.classList.add('selected'); window.selectedChar = c.id; } 
            else {
                if (game.souls >= c.cost) {
                    if(confirm(`Comprar ${c.name} por ${c.cost} almas?`)) {
                        game.souls -= c.cost; game.updateSoulsUI(); unlockedData.push(c.id); localStorage.setItem('unlockedChars', JSON.stringify(unlockedData)); location.reload();
                    }
                }
            }
        };
        select.appendChild(el);
    });
    window.selectedChar = 1; requestAnimationFrame(() => game.loop());
}

function startGameSingle() {
    audioManager.playWav('botton');
    audioManager.play('principal'); 
    document.getElementById('hud-top-left').style.display = 'block'; 
    document.getElementById('pause-btn-ingame').style.display = 'block'; 
    document.getElementById('perk-list-btn').style.display = 'block'; 
    document.getElementById('stats-btn').style.display = 'block'; 
    document.getElementById('souls-container').style.opacity = '1';
    document.getElementById('main-menu').classList.add('hidden'); 
    game.start(window.selectedChar);
}

function confirmBossWave() { document.getElementById('boss-confirm-menu').classList.add('hidden'); game.triggerConfirmedBossWave(); }
function returnToMenu() { location.reload(); }

window.onload = initGame;
</script>
</body>
</html>
